{"version":3,"file":"main.0b72185a.iframe.bundle.js","mappings":";;;;AAqCA;AC9BA;ACyGA;AC4EA;ACvLA;;AD0LA;AACA;AACA;;;AAGA;AEnMA;;AFsMA;AACA;AACA;;;;AGrMA;AASA;AAGA;ACQA;AACA;AACA;;AAEA;;AAEA;AClBA;AACA;AACA;;AAEA;AACA;;;ACUA;;;;;AAUA;AACA;AACA;;ACIA;;;;AAIA;AACA;;AAEA;AACA;;;AAGA;ACoBA;AACA;AACA;;AAIA;AChEA;AACA;AACA;;AAEA;AACA;;;AAGA;ACNA;AACA;;AAEA;;;;;;;;;;;;;;;;;;ACJA;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;AACA;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;AAIA;ACmBA;AAEA;;AAEA;AACA;;AA9BA;AASA;;;;AAIA;;;;AARA;AA4BA;AACA;;AAIA;;AAEA;;AAEA;AAQA;AACA;AAGA;;AAGA;AACA;AACA;;;;AAMA;;AAEA;AACA;;AAEA;AChFA;;AAWA;AANA;;AAQA;ACgCA;AACA;AACA;AACA;;;AAKA;AAoBA;AACA;;AAQA;AAKA;AACA;;AAIA;AAuBA;AACA;AACA;;AAGA;AAQA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;;AAEA;;AAGA;ACjHA;;AAfA;;;AAoBA;;AAGA;ACdA;AACA;;AAEA;;AAEA;ACAA;AACA;AACA;;AAGA;;AAOA;ACTA;;AAEA;AACA;AACA;;AAEA;AC5BA;AACA;AAEA;AACA;AACA;AACA;ACoBA;;AAEA;AACA;;;;;AAKA;AAOA;AAUA;;AAEA;AACA;;;AAGA;AAOA;AAMA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;;ACtFA;AACA;;;ACTA;;ACsBA;AACA;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAIA;;ACZA;AACA;;AC9BA;ADmCA;AACA;;AAGA;AAYA;AACA;AACA;AAEA;;AE1CA;AACA;;AAEA;;AAGA;AFmDA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAIA;;AGhEA;;;AAGA;AC2BA;AACA;AACA;AACA;AASA;ACCA;AAGA;AAUA;AC+CA;AACA;AACA;AACA;AACA;;;AAKA;;ACzGA;;AAEA;;;AAKA;;AAEA;;AAIA;;AAEA;;AAEA;AC3CA;;;;;;;;;;;;;;;;;;;ACkBA;AF2DA;;AAEA;;;AAGA;;AAQA;;;AEzCA;AACA;AACA;;AAEA;AAEA;;AAcA;AACA;AACA;;AAEA;;AAEA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AC5DA;AACA;AACA;ACrCA;;;;;;ADwCA;AENA;;AAEA;AACA;;AAEA;AACA;;;;AAIA;ACDA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;AAIA;AAEA;;AAEA;;AAGA;ACnCA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;ACqHA;ACnJA;;;;;;;AASA;APuFA;AACA;;;AAGA;;AQmGA;AC9KA;AACA;;AAGA;;AAGA;AD+KA;;;;AAIA;AACA;AACA;;AAIA;AA2QA;;AAIA;;;;AA8FA;;;;AEphBA","sources":["webpack://storybook/../lib/core/components/Infinity/components/Scroller.ts","webpack://storybook/../lib/core/components/Infinity/components/ContentWrapper.ts","webpack://storybook/../lib/core/components/Infinity/infinity-list.ts","webpack://storybook/../lib/core/plugins/hover-line/line-tooltip/LineTooltip.ts","webpack://storybook/../lib/core/plugins/hover-line/line-tooltip/constants/style.ts","webpack://storybook/../lib/core/plugins/hover-line/line-tooltip/constants/class-names.ts","webpack://storybook/../lib/core/plugins/hover-line/line-tooltip/util/createOrGetOverlay.ts","webpack://storybook/../lib/core/visualizations/charts/kpi/renderers/TrendElement.ts","webpack://storybook/../lib/core/visualizations/charts/kpi/renderers/CompareElement.ts","webpack://storybook/../lib/core/visualizations/charts/kpi/renderers/ContentElement.ts","webpack://storybook/../lib/core/visualizations/charts/kpi/renderers/HeaderElement.ts","webpack://storybook/../lib/core/visualizations/charts/kpi/KpiChart.ts","webpack://storybook/../lib/core/plugins/legend/util/mapLegendItem.ts","webpack://storybook/../lib/core/plugins/legend/util/renderOrdinalLegend.ts","webpack://storybook/../lib/core/plugins/message-handler/internal/iconMapper.ts","webpack://storybook/../lib/core/plugins/tabular-legend/TabularLegend.ts","webpack://storybook/../lib/core/visualizations/charts/common/util/constructLegendContainer.ts","webpack://storybook/../lib/core/visualizations/charts/milestone-kpi/MilestoneKpiChart.ts","webpack://storybook/../lib/core/visualizations/common/createTrendLabel.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/AlignedLabel.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/renderers/TextCell.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/Bar.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/TextTrendLabel.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/ComponentWithLabel.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/renderers/ZeroLine.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/renderers/CustomCell.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/GanttBar.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/renderers/GanttChartBarCell.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/util/getGanttLines.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/GanttLabel.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/renderers/ReferenceLine.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/SimpleBar.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/StackedBar.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/renderers/CompareBarCell.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/renderers/HeaderCell.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/sorting/SortIcon.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/TableHeader.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/ExpandButton.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/expand/ExpandIcon.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/TableRow.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/TableExpandableRow.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/ContentCell.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/row-renderers/GenericRowRenderer.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/util/scrollbarWidth.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/GenericTableRenderer.ts","webpack://storybook/../lib/core/visualizations/generic-table-renderer/components/TableFooter.ts","webpack://storybook/./stories/core/charts/factories/util/generateTreeData.ts"],"sourcesContent":["import './Scroller.scss';\n\nimport html from 'nanohtml';\n\nimport type { Direction } from '../models';\nimport { toPx } from '../utils';\nimport { maxBrowserScrollSize } from '../utils/maxBrowserScrollSize';\n\nexport interface ScrollerInstance {\n    element: HTMLElement;\n    setScrollerSize: (size: number) => void;\n}\n\ntype ScrollerProps = {\n    virtualSize: number;\n    direction: Direction;\n};\n\nconst calculateScrollerSize = ({\n    virtualSize,\n    direction,\n}: ScrollerProps) => {\n    const maxSize = maxBrowserScrollSize(direction);\n    const size = Math.min(maxSize, virtualSize);\n\n    return toPx(size);\n};\n\nexport const Scroller = ({\n    virtualSize,\n    direction,\n}: ScrollerProps): ScrollerInstance => {\n    const element = html`\n        <div class=\"infinity-scroller\">\n        </div>\n    `;\n\n    const setScrollerSize = (size: number) => {\n        const scrollerSize = calculateScrollerSize({\n            virtualSize: size,\n            direction,\n        });\n        const sizeProp = direction === 'vertical' ? 'height' : 'minWidth';\n        element.style[sizeProp] = scrollerSize;\n    };\n\n    setScrollerSize(virtualSize);\n\n    return {\n        element,\n        setScrollerSize,\n    };\n};\n","import './ContentWrapper.scss';\n\nimport html from 'nanohtml';\n\nimport type { Direction } from '../models';\n\nexport const ContentWrapper = (direction: Direction = 'vertical') => html`\n    <div class=\"infinity-wrapper infinity-wrapper-${direction}\"></div>\n`;\n","import morphdom from 'morphdom';\n\nimport { ElementResizeObserver } from '../../common/util/ElementResizeObserver';\nimport {\n    coerceOffset,\n    coerceScroll,\n} from './coercion';\nimport type { ScrollerInstance } from './components';\nimport {\n    ContentWrapper,\n    Scroller,\n} from './components';\nimport type {\n    Direction,\n    InfinityListOptions,\n    InfinityRenderer,\n} from './models';\nimport { InfinityListState } from './models';\nimport {\n    decorateItem,\n    toPx,\n} from './utils';\n\nexport class InfinityList {\n    scroller: ScrollerInstance;\n    content: HTMLElement;\n\n    private _renderer: InfinityRenderer;\n    private _previousRange = [ Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER ];\n\n    private _scrolledItemsData: { startIndex: number; listSizeToStart: number } | null = null;\n\n    set scrollDistance(value: number) {\n        if (this._direction === 'vertical') {\n            this.viewport.scrollTop = value;\n        } else {\n            this.viewport.scrollLeft = value;\n        }\n    }\n\n    get range(): [number, number] {\n        const {\n            virtualScrollDistance,\n            viewportSize,\n        } = this._state;\n\n        const { overscan } = this.options;\n\n        let end = 0;\n\n        let {\n            start, listSize,\n        } = this._getStartIndexAndListSize(virtualScrollDistance);\n\n        // go from start until we reach height of the scroll to get the index of the first visible item\n        while (listSize < virtualScrollDistance) {\n            listSize += this._renderer.getItemSizeByIndex(start);\n            start++;\n        }\n\n        // save start index and size of the unvisible items to continue calculation on next scroll\n        // from current position\n        this._scrolledItemsData = {\n            startIndex: start !== 0 ? start - 1 : 0,\n            listSizeToStart: start !== 0 ? listSize - this._renderer.getItemSizeByIndex(start - 1) : 0,\n        };\n\n        listSize = 0;\n        end = start;\n\n        // go from start until we reach height of the viewport to get the index of the last visible item\n        while (listSize <= viewportSize) {\n            listSize += this._renderer.getItemSizeByIndex(end);\n            end++;\n        }\n\n        if (overscan != null) {\n            start = Math.max(0, start - (start % overscan));\n            end += overscan;\n        }\n\n        return [ start, Math.min(end, this.options.count) ];\n    }\n\n    private get _virtualSize() {\n        return this._renderer.getListSize();\n    }\n\n    private _state: InfinityListState;\n    private _direction: Direction;\n\n    constructor(\n        public viewport: HTMLElement,\n        public options: InfinityListOptions,\n    ) {\n        this._direction = options.direction ?? 'vertical';\n\n        this._renderer = this.options.renderer;\n        this._renderer['_refresh'] = () => this.render(true);\n\n        this._state = new InfinityListState({\n            scrollDistance: coerceScroll(this.viewport, this._direction),\n            viewportSize: coerceOffset(this.viewport, this._direction),\n            virtualSize: this._virtualSize,\n            direction: this._direction,\n        });\n\n        this.scroller = Scroller({\n            virtualSize: this._virtualSize,\n            direction: this._direction,\n        });\n\n        this.content = ContentWrapper(this._direction);\n\n        this.scroller.element.appendChild(this.content);\n        viewport.appendChild(this.scroller.element);\n\n        this.viewport.addEventListener('scroll', this.handleScroll);\n        ElementResizeObserver.Instance\n            .observe(this.viewport)\n            .subscribe(this.handleResize);\n        this.handleScroll();\n    }\n\n    destroy() {\n        this.viewport.removeEventListener('scroll', this.handleScroll);\n        ElementResizeObserver.Instance.unobserve(this.viewport);\n    }\n\n    handleResize = () => {\n        if (this._state.viewportSize === this.viewport.offsetHeight) {\n            return;\n        }\n\n        this._state.set({\n            viewportSize: this.viewport.offsetHeight,\n            scrollDistance: coerceScroll(this.viewport, this._direction),\n        });\n\n        requestAnimationFrame(() => this.render());\n    };\n\n    handleScroll = () => {\n        this._state.set({ scrollDistance: coerceScroll(this.viewport, this._direction) });\n        this.scrollDistance = this._state.scrollDistance;\n        requestAnimationFrame(() => this.render());\n    };\n\n    updateRowCount = (rowCount: number) => {\n        this.options.count = rowCount;\n\n        this.scroller.setScrollerSize(this._virtualSize);\n\n        this._state.set({\n            viewportSize: this.viewport.offsetHeight,\n            virtualSize: this._virtualSize,\n            scrollDistance: 0,\n        });\n        this.scrollDistance = 0;\n\n        this.render(true);\n    };\n\n    render = (force = false) => {\n        if (force) {\n            this._scrolledItemsData = null;\n        }\n\n        const [ start, end ] = this.range;\n        const [ pStart, pEnd ] = this._previousRange;\n        const isSameRange = pStart === start && pEnd === end;\n        if (isSameRange && !force) {\n            return;\n        }\n\n        this._previousRange = [ start, end ];\n\n        const scrollOffset = this._renderer.getListSize({\n            start: 0,\n            end: start,\n        }) - this._state.pageOffset;\n\n        const scrollProperty = this._direction === 'vertical' ? 'top' : 'left';\n        this.content.style.setProperty(scrollProperty, toPx(scrollOffset));\n\n        const fragment = document.createDocumentFragment();\n        const fragmentContainer = document.createElement('div');\n        fragment.appendChild(fragmentContainer);\n        const attachTriggerList: Function[] = [];\n\n        this._renderer\n            .render({\n                range: {\n                    start,\n                    end,\n                },\n                offset: start,\n            })\n            .map((item, index) => decorateItem({\n                item,\n                index,\n                offset: start,\n            }))\n            .forEach((child, index) => {\n                const vIndex = index + start;\n                fragmentContainer.appendChild(child);\n\n                if (vIndex > this.options.count - 1) {\n                    throw Error(`Your render implementation returned too many items. The range is exclusive: [${start}, ${end})`);\n                } else {\n                    attachTriggerList.push(() =>\n                        this._renderer.afterItemMount?.({\n                            index,\n                            vIndex,\n                        }),\n                    );\n                }\n            });\n\n        this._renderer.preMorph();\n        morphdom(\n            this.content,\n            fragment,\n            { childrenOnly: true }\n        );\n        this._renderer.postMorph();\n\n        attachTriggerList.forEach(handler => handler());\n    };\n\n    scrollToIndex = (index: number) => {\n        this._state.scrollTo(this._renderer.getListSize({\n            start: 0,\n            end: index,\n        }));\n        this.scrollDistance = this._state.scrollDistance;\n        this.render();\n    };\n\n    private _getStartIndexAndListSize = (virtualScrollDistance: number) => {\n        if (!this._scrolledItemsData) {\n            return {\n                start: 0,\n                listSize: 0,\n            };\n        }\n\n        const {\n            startIndex, listSizeToStart,\n        } = this._scrolledItemsData;\n\n        if (listSizeToStart <= virtualScrollDistance) {\n            // scrolled down, take last position to continue calculation\n            return {\n                start: startIndex,\n                listSize: listSizeToStart,\n            };\n        }\n        // scrolled up, go from current positon and decrease the start position until\n        // we reach the height of the scroll\n        let currentSize = listSizeToStart,\n            currentIndex = startIndex;\n\n        while (currentSize >= virtualScrollDistance && currentIndex > 0) {\n            currentIndex--;\n            currentSize -= this._renderer.getItemSizeByIndex(currentIndex);\n        }\n        return {\n            start: currentIndex,\n            listSize: currentSize,\n        };\n    };\n}\n","import './LineTooltip.scss';\n\nimport html from 'nanohtml';\nimport {\n    fromEvent,\n    Subject,\n    takeUntil,\n    tap,\n} from 'rxjs';\n\nimport {\n    assert,\n    getDataSetFromChart,\n    getValuesFromChart,\n} from '../../../common/util';\nimport type { ChartInstance } from '../../../models';\nimport type { LegendRow } from '../../tabular-legend';\nimport { TabularLegend } from '../../tabular-legend';\nimport {\n    CHART_TOOLTIP_CURSOR_ID,\n    CHART_TOOLTIP_ID,\n    CHART_TOOLTIP_INITIAL_STYLE,\n    TEXT_BOTTOM_ID,\n    TEXT_TOP_ID,\n    TOOLTIP_LINE_CLASS,\n    TOOLTIP_TEXT_CLASS,\n    TOOLTIP_TEXT_STYLE,\n} from './constants';\nimport type {\n    TooltipFormatter,\n    TooltipInfo,\n    TooltipModel,\n    TooltipProperties,\n    TooltipStructure,\n} from './models';\nimport {\n    CHART_OVERLAY_ID,\n    coerceFormatter,\n    createOrGetOverlay,\n    getTooltipArea,\n    setLabelTextStyle,\n    setTooltipPosition,\n    setTooltipStyle,\n} from './util';\n\nexport class LineTooltip<TMetaData> {\n    private _chart: ChartInstance<TMetaData>;\n    private _formatter: TooltipFormatter<TMetaData>;\n    private _hideCallback: () => void;\n\n    private _destroyed$ = new Subject<void>();\n\n    private get _tooltip(): TooltipStructure {\n        return this._createOrGetTooltip();\n    }\n\n    constructor({\n        chart,\n        tooltipFormatter = {},\n        hideCallback,\n    }: TooltipProperties<TMetaData>) {\n        this._formatter = coerceFormatter(tooltipFormatter) ?? this._getDefaultFormatter;\n        this._hideCallback = hideCallback;\n        this._chart = chart;\n    }\n\n    isTooltip(element: Element) {\n        return element.classList.contains(TOOLTIP_TEXT_CLASS);\n    }\n\n    destroy() {\n        this._destroyed$.next();\n        this._destroyed$.complete();\n        document.getElementById(CHART_OVERLAY_ID)?.remove();\n    }\n\n    hide = () => {\n        this._chart.container.removeAttribute('aria-describedby');\n        document.getElementById(CHART_OVERLAY_ID)?.remove();\n    };\n\n    update(\n        model: TooltipModel,\n    ) {\n        const tooltipArea = getTooltipArea(this._chart);\n\n        setTooltipStyle(this._tooltip.container, tooltipArea, model);\n\n        const index = model.dataIndex;\n\n        const values = getValuesFromChart(this._chart, index);\n\n        assert(values.length > 0, 'Expected the tooltip to have data points and colors.');\n\n        const dataset = getDataSetFromChart(this._chart);\n        const source = this._formatter({\n            colors: values.map(({ color }) => color),\n            data: values.map(({ value }) => value),\n            meta: dataset.meta?.[index],\n        });\n\n        this._applyLabel(this._tooltip.topText, source.yLabel);\n        this._applyLabel(this._tooltip.bottomText, source.xLabel);\n\n        setTooltipPosition(this._tooltip.container, tooltipArea, model);\n\n        this._setCursorHeight();\n        this._setBottomTextVisibility();\n\n        setLabelTextStyle(this._tooltip.bottomText, tooltipArea);\n        setLabelTextStyle(this._tooltip.topText, tooltipArea);\n\n        this._chart.container.setAttribute('aria-describedby', CHART_OVERLAY_ID);\n    }\n\n    private _applyLabel(element: HTMLDivElement, legendSchema: LegendRow[] = []) {\n        if (legendSchema.length > 0) {\n            element.style.visibility = 'visible';\n            element.innerHTML = '';\n            element.appendChild(TabularLegend(legendSchema));\n        } else {\n            element.style.visibility = 'hidden';\n        }\n    }\n\n    private _tooltipCells(value: Date | string | number, color?: string): LegendRow {\n        return {\n            cells: [ {\n                text: value.toLocaleString(),\n                color,\n            } ],\n        };\n    }\n\n    private _getDefaultFormatterMulti({\n        data,\n        colors,\n    }: TooltipInfo<TMetaData>) {\n        const hasSameXValues = data.every(({ x }) => x === data[0].x);\n\n        return {\n            xLabel: hasSameXValues\n                ? [ this._tooltipCells(data[0].x) ]\n                : data.map(({ x }, index) => this._tooltipCells(x, colors[index])),\n            yLabel: data.map(({ y }, index) => this._tooltipCells(y, colors[index])),\n        };\n    }\n\n    private _getDefaultFormatterSingle({ data }: TooltipInfo<TMetaData>) {\n        return {\n            xLabel: data.map(({ x }) => this._tooltipCells(x)),\n            yLabel: data.map(({ y }) => this._tooltipCells(y)),\n        };\n    }\n\n    private _getDefaultFormatter(info: TooltipInfo<TMetaData>) {\n        return info.data.length > 1\n            ? this._getDefaultFormatterMulti(info)\n            : this._getDefaultFormatterSingle(info);\n    }\n\n    private _getStructure(container: HTMLDivElement) {\n        const structure = {\n            container,\n            cursor: document.getElementById(CHART_TOOLTIP_CURSOR_ID) as HTMLDivElement,\n            topText: document.getElementById(TEXT_TOP_ID) as HTMLDivElement,\n            bottomText: document.getElementById(TEXT_BOTTOM_ID) as HTMLDivElement,\n        };\n\n        this._destroyed$.next();\n        fromEvent([ structure.topText, structure.bottomText ], 'mouseout')\n            .pipe(\n                tap(this._hideCallback),\n                takeUntil(this._destroyed$),\n            )\n            .subscribe();\n\n        return structure;\n    }\n\n    private _createOrGetTooltip() {\n        let container = document.getElementById(CHART_TOOLTIP_ID) as HTMLDivElement;\n\n        if (container) {\n            return this._getStructure(container);\n        }\n\n        container = html`\n            <div id=\"${CHART_TOOLTIP_ID}\" role=\"tooltip\"\n                style=\"${CHART_TOOLTIP_INITIAL_STYLE}\">\n\n                <div id=\"${TEXT_TOP_ID}\"\n                    class=\"${TOOLTIP_TEXT_CLASS}\"\n                    style=\"${TOOLTIP_TEXT_STYLE}\">\n                </div>\n\n                <div id=\"${CHART_TOOLTIP_CURSOR_ID}\"\n                    class=\"${TOOLTIP_LINE_CLASS}\"></div>\n\n                <div id=\"${TEXT_BOTTOM_ID}\"\n                    class=\"${TOOLTIP_TEXT_CLASS}\"\n                    style=\"${TOOLTIP_TEXT_STYLE}\">\n                </div>\n\n            </div>\n        ` as HTMLDivElement;\n\n        createOrGetOverlay()\n            .appendChild(container);\n\n        return this._getStructure(container);\n    }\n\n    private _setCursorHeight() {\n        const cursorRect = this._tooltip.cursor.getBoundingClientRect();\n\n        this._tooltip.cursor.style.height = cursorRect.bottom > document.documentElement.clientHeight\n            ? `${document.documentElement.clientHeight - cursorRect.top}px` : '';\n    }\n\n    private _setBottomTextVisibility() {\n        const bottomY = this._tooltip.bottomText.getBoundingClientRect().bottom;\n\n        this._tooltip.bottomText.style.display = bottomY > document.documentElement.clientHeight\n            ? 'none' : '';\n    }\n}\n","export const TOOLTIP_TEXT_STYLE = `\n    padding: 5px;\n    height: auto;\n`;\n\nexport const CHART_TOOLTIP_INITIAL_STYLE = 'display: none;';\n","export const TOOLTIP_TEXT_CLASS = 'chart-tooltip-text';\nexport const TOOLTIP_LINE_CLASS = 'chart-tooltip-line';\n","import html from 'nanohtml';\n\nexport const CHART_OVERLAY_ID = 'chart-overlay-container';\n\nexport const createOrGetOverlay = () => {\n    let overlay = document\n        .getElementById(CHART_OVERLAY_ID);\n\n    if (overlay) {\n        return overlay;\n    }\n\n    overlay = html`\n        <div id=${CHART_OVERLAY_ID}></div>\n    `;\n\n    document.body.append(overlay);\n\n    return overlay;\n};\n","import html from 'nanohtml';\n\nimport { createTrendLabel } from '../../../common/createTrendLabel';\nimport {\n    KPI_COMPARE_WRAPPER,\n    KPI_VALUE,\n} from '../constants';\nimport type { KpiContent } from '../models';\n\nexport const TrendElement = ({\n    value,\n    compareValue,\n    trendDirection,\n    trendColor,\n}: KpiContent) => {\n    const compareElement = compareValue\n        ? createTrendLabel({\n            compareValue,\n            direction: trendDirection ?? 'down',\n            color: trendColor,\n        })\n        : undefined;\n\n    return html`\n        <div class=\"${KPI_COMPARE_WRAPPER}\">\n            <p class=\"${KPI_VALUE}\">\n                ${value}\n            </p>\n            ${compareElement}\n        </div>\n    `;\n};\n","import html from 'nanohtml';\n\nimport {\n    KPI_CONTENT_COMPARE,\n    KPI_VALUE,\n} from '../constants';\nimport type { KpiContent } from '../models';\n\nexport const CompareElement = ({\n    value,\n    compareValue,\n}: KpiContent) => html`\n<div class=\"${KPI_CONTENT_COMPARE}\">\n    <p class=\"${KPI_VALUE}\">\n        ${value}\n    </p>\n    <p class=\"${KPI_VALUE}\">\n        ${compareValue}\n    </p>\n</div>\n`;\n","import html from 'nanohtml';\n\nimport { KPI_SUBTITLE } from '../constants';\nimport type { KpiContent } from '../models';\nimport { CompareElement } from './CompareElement';\nimport { TrendElement } from './TrendElement';\n\nexport const ContentElement = ({\n    value,\n    compareValue,\n    subtitle,\n    trendDirection,\n    trendColor,\n    comparison,\n}: KpiContent) => {\n\n    const subtitleElement = subtitle\n        ? html`<p class=\"${KPI_SUBTITLE}\">${subtitle}</p>`\n        : undefined;\n\n    const contentElement = comparison === 'trend'\n        ? TrendElement({\n            value,\n            compareValue,\n            trendDirection,\n            trendColor,\n        })\n        : CompareElement({\n            value,\n            compareValue,\n        });\n\n    return html`\n        <div style=\"\n            width: fit-content;\n            overflow: hidden;\n        \">\n            ${contentElement}\n            ${subtitleElement}\n        </div>`;\n};\n","import html from 'nanohtml';\n\nimport {\n    KPI_HEADER,\n    KPI_TITLE,\n    KPI_WRAPPER_TEXT,\n    KPI_WRAPPER_TEXT_LINE,\n} from '../constants';\nimport type { KpiTextData } from '../models';\nimport { ContentElement } from './ContentElement';\n\ninterface HeaderElementProps<TTextMetaData> {\n    textData: KpiTextData<TTextMetaData>;\n    hasChart: boolean;\n}\n\nexport const HeaderElement = <TTextMetaData>({\n    textData,\n    hasChart,\n}: HeaderElementProps<TTextMetaData>) => {\n    const {\n        content,\n        title,\n    } = textData;\n\n    const contentElement = content.map(({\n        value,\n        compareValue,\n        subtitle,\n        trendDirection,\n        comparison = 'trend',\n        trendColor,\n    }) => ContentElement({\n        value,\n        compareValue,\n        subtitle,\n        trendDirection,\n        comparison,\n        trendColor,\n    }));\n\n    return html`\n        <div\n            class=\"${KPI_HEADER}\"\n            tabindex=\"0\"\n            role=\"figure\"\n        >\n            <div class=\"${KPI_TITLE}\">\n                ${title}\n            </div>\n            <div class=\"${hasChart ? KPI_WRAPPER_TEXT_LINE : KPI_WRAPPER_TEXT}\">\n                ${contentElement}\n            </div>\n        </div>\n    `;\n};\n","import './KpiChart.scss';\n\nimport clsx from 'clsx';\nimport html from 'nanohtml';\nimport type { Instance } from 'tippy.js';\nimport { delegate } from 'tippy.js';\n\nimport { AL_HAS_COMPARISON } from '../../../common/constants';\nimport { DEFAULT_TIPPY_PROPERTIES } from '../../../common/constants/defaultTippyProperties';\nimport type { Chart } from '../chart';\nimport type { LineChart } from '../line/LineChart';\nimport {\n    KPI,\n    KPI_CHART,\n    KPI_HEADER_SELECTOR,\n    KPI_NO_DATA,\n    KPI_SMALL_SIZE,\n} from './constants';\nimport type {\n    KpiChartProps,\n    KpiTextData,\n} from './models';\nimport { HeaderElement } from './renderers';\nimport {\n    defaultRenderTooltip,\n    getChartData,\n} from './util';\n\nexport class KpiChart<TChartMetaData = unknown, TTextMetaData = unknown> {\n    readonly chart?: LineChart<TChartMetaData> | Chart;\n\n    private _textElement: HTMLElement;\n    private _chartElement?: HTMLDivElement;\n    private _tooltip: Instance;\n    private _container: HTMLElement;\n    private _textData: KpiTextData<TTextMetaData>;\n    private _renderTooltip: (data: KpiTextData<TTextMetaData>) => HTMLElement;\n\n    constructor({\n        textData,\n        container,\n        chartData,\n        size = 'default',\n        renderTooltip,\n    }: KpiChartProps<TChartMetaData, TTextMetaData>) {\n        const hasChartData = chartData?.data !== undefined && chartData.data.length > 0;\n        const hasKpiData = textData.content.length > 0;\n        const hasData = hasChartData || hasKpiData;\n        const hasCompareData = textData.content\n            .find(c => c.compareValue && c.comparison === 'compare');\n\n        this._renderTooltip = renderTooltip ?? defaultRenderTooltip;\n\n        this._textData = textData;\n        this._textElement = HeaderElement({\n            textData,\n            hasChart: hasChartData,\n        });\n\n        if (chartData) {\n            this._chartElement = document.createElement('div');\n            this._chartElement.classList.add(KPI_CHART);\n\n            this.chart = getChartData(this._chartElement, chartData);\n        }\n\n        const kpiClass = clsx(\n            KPI,\n            size === 'small' && KPI_SMALL_SIZE,\n            !hasData && KPI_NO_DATA,\n            hasCompareData && AL_HAS_COMPARISON\n        );\n\n        this._container = html `\n            <div class=\"${kpiClass}\">\n                ${this._textElement}\n                ${this._chartElement}\n            </div>\n        `;\n\n        this._tooltip = delegate(this._container, {\n            ...DEFAULT_TIPPY_PROPERTIES,\n            onShow: this._onTooltipShow,\n            target: KPI_HEADER_SELECTOR,\n            appendTo: this._container,\n        });\n\n        container.append(this._container);\n    }\n\n    destroy() {\n        this.chart?.destroy();\n        this._tooltip.destroy();\n\n        this._chartElement?.remove();\n        this._textElement.remove();\n        this._container.remove();\n    }\n\n    private _onTooltipShow = (instance: Instance): void | false => {\n        const content = this._renderTooltip(this._textData);\n        instance.setContent(content);\n    };\n}\n","import clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport {\n    DUF_LEGEND_COLOR,\n    DUF_LEGEND_ITEM,\n    DUF_LEGEND_LABEL,\n} from '../../../common/constants';\nimport { isOrdinalLegendColors } from '../models';\n\nexport const mapLegendItem = (label: string, color: string) => {\n    const isValidCssColor = isOrdinalLegendColors([ color ]);\n    const style = isValidCssColor ? `background-color: ${color};` : '';\n    const colorClass = isValidCssColor ? undefined : color;\n\n    return html`\n        <div class=\"${DUF_LEGEND_ITEM}\">\n            <div class=\"${clsx(DUF_LEGEND_COLOR, colorClass)}\"\n                style=\"${style}\">\n            </div>\n            <div class=\"${DUF_LEGEND_LABEL}\">\n                <label>${label}</label>\n            </div>\n        </div>\n    `;\n};\n","import html from 'nanohtml';\n\nimport { DUF_LEGEND_ITEM_CONTAINER } from '../../../common/constants';\nimport { assert } from '../../../common/util';\nimport type { OrdinalLegendProps } from '../models';\nimport { mapLegendItem } from './mapLegendItem';\n\nexport const renderOrdinalLegend = ({\n    labels,\n    colors,\n}: OrdinalLegendProps) => {\n    assert(labels.length === colors.length, 'Expected an ordinal legend to have the same number of colors as labels.');\n\n    const legendItems = labels.map((label, index) =>\n        mapLegendItem(label, colors[index])\n    );\n\n    return html`\n        <div class=\"${DUF_LEGEND_ITEM_CONTAINER}\">\n            ${legendItems}\n        </div>\n    `;\n};\n","import { ComponentType } from '../constants';\nimport {\n    noBarDataIllustration,\n    noDataIllustration,\n    noGraphDataIllustration,\n    noHorizontalBarDataIllustration,\n    noLineDataIllustration,\n    noPieDataIllustration,\n    noTableDataIllustration,\n    noTreeDataIllustration,\n} from '../illustrations';\nimport { MessageStatus } from '../models/MessageStatus';\n\nexport const iconMapper = (status?: MessageStatus, componentType?: ComponentType) => {\n    if (status === MessageStatus.NoData) {\n        switch (componentType) {\n            case ComponentType.LineChart: return noLineDataIllustration();\n            case ComponentType.BarChart: return noBarDataIllustration();\n            case ComponentType.HorizontalBarChart: return noHorizontalBarDataIllustration();\n            case ComponentType.PieChart: return noPieDataIllustration();\n            case ComponentType.Table: return noTableDataIllustration();\n            case ComponentType.ProcessGraph: return noGraphDataIllustration();\n            case ComponentType.TreeChart: return noTreeDataIllustration();\n            default: return noDataIllustration();\n        }\n    }\n\n    return undefined;\n};\n","import './TabularLegend.scss';\n\nimport clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport { GTR_LEGEND_CONTENT } from '../../common/constants';\n\nexport type LegendCell = {\n    text: string;\n    color?: string;\n    colorClass?: string;\n    align?: 'right' | 'left';\n    role?: 'primary' | 'secondary';\n    content?: HTMLElement;\n};\n\nexport type LegendRow = {\n    isSeparated?: boolean;\n    cells: LegendCell[];\n};\n\nconst mapColor = (cell: LegendCell) => {\n    const hasSpecificColor = cell.color !== undefined;\n    const hasColorClass = cell.colorClass !== undefined;\n\n    if (!hasSpecificColor && !hasColorClass) {\n        return '';\n    }\n\n    return html`\n        <div class=\"${clsx('block', cell.colorClass)}\"\n            style=\"\n                outline: 1px inset rgba(0, 0, 0, 0.1);\n                border-radius: 50%;\n                ${!hasColorClass ? `background-color: ${cell.color};` : ''}\n                display: inline-block'};\n            \">\n        </div>\n    `;\n};\n\nconst mapLegendCell = (cell: LegendCell) => {\n    const alignment = cell.align === 'right' ? 'flex-end' : 'flex-start';\n\n    const content = cell.content\n        ? html`<div class=\"${GTR_LEGEND_CONTENT}\">\n            ${cell.content}\n        </div>`\n        : html`\n            <div\n                class=\"${GTR_LEGEND_CONTENT}\"\n                style=\"justify-content: ${alignment}\"\n            >\n                ${mapColor(cell)}\n                <label class=\"${cell.role ?? 'primary'}\">\n                        ${cell.text}\n                </label>\n            </div>`;\n\n    return html`\n        <td>\n            ${content}\n        </td>\n    `;\n};\n\nexport const TabularLegend = (rows: LegendRow[], title?: string) => {\n    const tableContent = rows.map(({\n        cells,\n        isSeparated,\n    }) => html`\n        <tr class=\"${clsx(isSeparated && 'row-separator')}\">\n            ${cells.map((cell) => mapLegendCell(cell))}\n        </tr>`);\n\n    const maxColumns = Math.max(...rows.map(({ cells }) => cells.length));\n    const tableHeader = title && html`\n        <tr>\n            <th colspan=\"${maxColumns}\">\n                <div class=\"${GTR_LEGEND_CONTENT}\">\n                    ${title}\n                </div>\n            </th>\n        </tr>\n    `;\n\n    return html`\n        <table class=\"cr-tabular-legend\">\n            ${ tableHeader }\n            ${ tableContent }\n        </table>\n    `;\n};\n","import html from 'nanohtml';\n\nimport type { LegendProps } from '../../../../plugins/legend';\nimport {\n    CONTENT_CONTAINER_CLASS,\n    LEGEND_CONTAINER_CLASS,\n} from '../../../common/constants';\n\nconst LEGEND_HEIGHT = 32;\n\nconst createLegendContainer = () => html`\n        <div class=\"${LEGEND_CONTAINER_CLASS}\" style=\"width: 100%; height: ${LEGEND_HEIGHT}px;\">\n        </div>\n    `;\n\nconst createContentContainer = () => html`\n        <div class=\"${CONTENT_CONTAINER_CLASS}\" style=\"width: 100%; height: calc(100% - ${LEGEND_HEIGHT}px)\">\n        </div>\n    ` as HTMLDivElement;\n\nexport const constructLegendContainer = (container: HTMLDivElement, legendProperties?: LegendProps) => {\n    const legendContainer = createLegendContainer();\n    const contentContainer = createContentContainer();\n\n    container.childNodes.forEach((child) => contentContainer.appendChild(child));\n    container.innerHTML = '';\n\n    const elementOrder = legendProperties?.position === 'bottom'\n        ? [ contentContainer, legendContainer ]\n        : [ legendContainer, contentContainer ];\n\n    elementOrder.forEach(element => container.appendChild(element));\n\n    return legendContainer;\n};\n","import './MilestoneKpiChart.scss';\n\nimport clsx from 'clsx';\nimport { select } from 'd3';\nimport html from 'nanohtml';\n\nimport { MilestoneBar } from '../../../components/MilestoneBar';\nimport {\n    MILESTONE,\n    MILESTONE_CONTENT,\n    MILESTONE_CONTENT_COLUMN,\n    MILESTONE_CONTENT_ROW,\n    MILESTONE_CONTENT_TEXT,\n    MILESTONE_CONTENT_WRAPPER,\n    MILESTONE_DIVIDER,\n    MILESTONE_KPI,\n    MILESTONE_SUB_CONTENT_TEXT,\n    MILESTONE_SUBTITLE,\n    MILESTONE_SUBTITLE_LABEL,\n    MILESTONE_TITLE,\n} from './constants';\nimport type {\n    MilestoneKpiChartProps,\n    MilestoneLabelProps,\n    MilestoneSubtitle,\n} from './models/MilestoneKpiChartProps';\n\nconst SUBTITLE_ICON_FONT_SIZE = 10;\n\nexport class MilestoneKpiChart {\n    private _container: HTMLElement;\n    private _milestoneBar?: MilestoneBar;\n\n    constructor(props: MilestoneKpiChartProps) {\n        const {\n            container,\n            title,\n            subtitle,\n        } = props;\n        const isMilestoneType = 'milestone' in props;\n\n        const content = isMilestoneType\n            ? this._renderContentBar(props.primary)\n            : this._renderContentBase(\n                props.primary,\n                props.secondary,\n            );\n\n        const className = clsx(\n            MILESTONE_CONTENT_WRAPPER,\n            isMilestoneType && MILESTONE,\n        );\n\n        const titleElement = this._renderTitle(title, subtitle);\n\n        this._container = html `\n            <div class=${MILESTONE_KPI}>\n                <div class=${className}>\n                    ${titleElement}\n                    ${content}\n                </div>\n            </div>\n        `;\n\n        this._milestoneBar = isMilestoneType\n            ? new MilestoneBar({\n                container: this._container,\n                ...props.milestone,\n            })\n            : undefined;\n\n        container.append(this._container);\n    }\n\n    destroy() {\n        this._milestoneBar?.destroy();\n        this._container.remove();\n    }\n\n    private _renderTitle(\n        title: string,\n        subtitle?: MilestoneSubtitle\n    ) {\n        const titleElement = html`\n            <div class=\"${MILESTONE_CONTENT_COLUMN}\">\n                <span class=${MILESTONE_TITLE}>${title}</span>\n            </div>\n        `;\n\n        if (subtitle) {\n            titleElement.append(this._renderSubtitle(subtitle));\n        }\n\n        return titleElement;\n    }\n\n    private _renderSubtitle(subtitle: MilestoneSubtitle) {\n        const subtitleElement = html`\n            <div class=\"${MILESTONE_SUBTITLE}\">\n                <span class=\"${MILESTONE_SUBTITLE_LABEL}\">${subtitle.label}</span>\n            </div>\n        `;\n\n        if (subtitle?.icon) {\n            const iconClone = subtitle.icon.cloneNode(true) as SVGElement;\n            select(iconClone)\n                .attr('width', SUBTITLE_ICON_FONT_SIZE)\n                .attr('height', SUBTITLE_ICON_FONT_SIZE);\n\n            subtitleElement.prepend(iconClone);\n        }\n\n        return subtitleElement;\n    }\n\n    private _renderContentBar(\n        {\n            value,\n            label,\n        }: MilestoneLabelProps,\n    ) {\n        const className = clsx(\n            MILESTONE_CONTENT_ROW,\n            MILESTONE,\n        );\n        return html`\n            <div class=${className}>\n                <span class=${MILESTONE_CONTENT}><b>${value}</b></span>\n                <span class=${MILESTONE_CONTENT}>${label}</span>\n            </div>\n        `;\n    }\n\n    private _renderContentBase(\n        primary: MilestoneLabelProps,\n        secondary?: MilestoneLabelProps,\n    ) {\n        const subContentElement = secondary\n            ? html`\n                <div class=${MILESTONE_DIVIDER}></div>\n                <div class=${MILESTONE_CONTENT_COLUMN}>\n                    <span class=${MILESTONE_CONTENT_TEXT}>${secondary.value}</span>\n                    <span class=${MILESTONE_SUB_CONTENT_TEXT}>${secondary.label}</span>\n                </div>`\n            : undefined;\n\n        return html`\n            <div class=${MILESTONE_CONTENT_ROW}>\n                <div class=${MILESTONE_CONTENT_COLUMN}>\n                    <span class=${MILESTONE_CONTENT_TEXT}>${primary.value}</span>\n                    <span class=${MILESTONE_SUB_CONTENT_TEXT}>${primary.label}</span>\n                </div>\n                ${subContentElement}\n            </div>\n        `;\n    }\n}\n","import './TrendLabel.scss';\n\nimport clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport {\n    TRENDING_DOWN,\n    TRENDING_UP,\n} from '../../common/constants/svgPaths';\nimport {\n    createSVGIcon,\n    SVG_ICON_S,\n} from '../../common/util/createSVGIcon';\nimport {\n    TREND_LABEL_WRAPPER,\n    TREND_NEGATIVE_COLOR,\n    TREND_POSITIVE_COLOR,\n} from './constants';\nimport type { Trend } from './models/Trend';\n\nexport function createTrendLabel(trend: Trend) {\n    const {\n        direction,\n        compareValue,\n        color,\n    } = trend;\n\n    const getTrendIcon = (): SVGSVGElement => createSVGIcon({\n        path: direction === 'up' ? TRENDING_UP : TRENDING_DOWN,\n        size: SVG_ICON_S,\n    });\n\n    const defaultColor = direction === 'up' ? 'positive' : 'negative';\n    const trendColor = color ?? defaultColor;\n\n    const trendClass = clsx(\n        trendColor === 'positive' && TREND_POSITIVE_COLOR,\n        trendColor === 'negative' && TREND_NEGATIVE_COLOR,\n        TREND_LABEL_WRAPPER,\n    );\n\n    return html`\n        <div class=\"${trendClass}\">\n            <div style='display: flex; align-items: center'>\n                ${getTrendIcon()}\n            </div>\n            <div style='white-space: nowrap; text-overflow: ellipsis; overflow: hidden'>\n                ${compareValue}\n            </div>\n        </div>`;\n}\n","import './AlignedLabel.scss';\n\nimport clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport type { TextAlignment } from '../../../common/constants';\nimport {\n    GTR_ALIGN_RIGHT_CLASS,\n    GTR_ALIGNED_LABEL_CLASS,\n    GTR_ALIGNED_WRAPPER_CLASS,\n} from '../../../common/constants';\nimport { createTrendLabel } from '../../common/createTrendLabel';\nimport type { Trend } from '../../common/models/Trend';\n\ntype LabelProps = {\n    label: string;\n    align: TextAlignment;\n    trend?: Trend;\n};\n\nexport const AlignedLabel = ({\n    label,\n    align,\n    trend,\n}: LabelProps) => {\n    const isAlignedRight = align === 'right';\n    const wrapperClass = clsx(\n        GTR_ALIGNED_WRAPPER_CLASS,\n        isAlignedRight && GTR_ALIGN_RIGHT_CLASS\n    );\n\n    const labelClass = clsx(\n        GTR_ALIGNED_LABEL_CLASS,\n    );\n\n    return html`<div class=\"${wrapperClass}\">\n        <div class=\"${labelClass}\">\n            ${label}\n        </div>\n        ${trend && createTrendLabel(trend)}\n    </div>\n    `;\n};\n","import './TextCell.scss';\n\nimport clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport type { TextAlignment } from '../../../common/constants';\nimport { GTR_TEXT_CLASS } from '../../../common/constants';\nimport type { Trend } from '../../common/models/Trend';\nimport { AlignedLabel } from '../components/AlignedLabel';\nimport type { RoleType } from '../models';\n\nexport type TextCellValue = string | number | Date | boolean | null;\nexport type TextCellData = {\n    value: TextCellValue;\n    label: string;\n    trend?: Trend;\n} | string;\n\ntype TextCellProps = {\n    data: TextCellData;\n    role?: RoleType;\n    style?: string;\n    className?: string;\n    align?: TextAlignment;\n};\n\nexport const TextCell = ({\n    data,\n    role = 'none',\n    align = 'left',\n    style = '',\n    className = '',\n}: TextCellProps) => {\n    const textCellClass = clsx(\n        GTR_TEXT_CLASS,\n        className\n    );\n    const label = typeof data === 'string' ? data : data.label;\n    const trend = typeof data === 'string' ? undefined : data.trend;\n\n    return html`\n        <div class=\"${textCellClass}\"\n             role=\"${role}\"\n             style=\"${style}\"\n        >\n            ${\n    AlignedLabel({\n        label,\n        align,\n        trend,\n    })\n}\n        </div>\n    ` as HTMLDivElement;\n};\n","import html from 'nanohtml';\n\ntype BarProps = {\n    value: number;\n    color: string;\n    min: number;\n    max: number;\n    widthDenominator: number;\n    widthPositiveNumbers: number;\n    className: string;\n};\n\nconst valueClass = (value: number) => {\n    if (value === 0) {\n        return 'zero';\n    }\n\n    return value < 0\n        ? 'negative'\n        : 'positive';\n};\n\nexport const Bar = ({\n    value,\n    min,\n    max,\n    color,\n    widthDenominator,\n    widthPositiveNumbers,\n    className,\n}: BarProps) => {\n    const isNegativeValue = value < 0;\n    const barWidth = Math.abs(value) / widthDenominator * 100;\n    const supportDivWidth = (Math.abs(min) - Math.abs(value)) / widthDenominator * 100;\n\n    const supportBarWidth = isNegativeValue\n        ? supportDivWidth\n        : widthPositiveNumbers;\n\n    const supportBarOffset = isNegativeValue && max > 0\n        ? -1\n        : 0;\n\n    return html`\n            <div class=\"${className} ${valueClass(value)}\"\n                style=\"\n                        width: ${barWidth}%;\n                        background-color: ${color};\n                        margin-left:calc(${supportBarWidth}% - ${supportBarOffset}px);\n                \">\n            </div> ` as HTMLDivElement;\n};\n","import html from 'nanohtml';\n\nimport { createTrendLabel } from '../../common/createTrendLabel';\nimport type { Trend } from '../../common/models/Trend';\n\ninterface TextTrendLabelProps {\n    trend?: Trend;\n    text: string;\n    trendLabelSide: 'left' | 'right';\n}\n\nexport const TextTrendLabel = ({\n    trend,\n    text,\n    trendLabelSide = 'right',\n}: TextTrendLabelProps) => {\n    const trendLabel = trend != null\n        ? createTrendLabel(trend)\n        : undefined;\n\n    return (trendLabelSide === 'right'\n        ? html`<>\n            ${text}\n            ${trendLabel}\n        </>`\n        : html`<>\n            ${trendLabel}\n            ${text}\n        </>`) as HTMLDivElement;\n};\n","import './ComponentWithLabel.scss';\n\nimport clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport {\n    GTR_COMPONENT_DYNAMIC_LABEL_CLASS,\n    GTR_COMPONENT_LABEL_CLASS,\n    GTR_COMPONENT_WITH_LABEL_CLASS,\n} from '../../../common/constants';\nimport type { Trend } from '../../common/models/Trend';\nimport { TextTrendLabel } from './TextTrendLabel';\n\nexport type LabelData = {\n    text: string;\n    size: number;\n    trend?: Trend;\n};\n\nexport interface Labels {\n    left?: LabelData;\n    right?: LabelData;\n}\n\nexport type ComponentWithLabelProps = {\n    component: HTMLElement;\n    labels: Labels;\n    contentWidth: number;\n    position: 'left' | 'right';\n    isAllPositive: boolean;\n    centerComponent?: boolean;\n    hasDynamicLabelPosition?: boolean;\n};\n\nexport const ComponentWithLabel = ({\n    component,\n    contentWidth,\n    position,\n    centerComponent,\n    isAllPositive,\n    labels,\n    hasDynamicLabelPosition,\n}: ComponentWithLabelProps) => {\n\n    const startPercentage = isAllPositive ? 0 : 50;\n\n    const leftLabelWidth = `calc(${position === 'left' ? contentWidth : startPercentage}% + ${labels.left?.size}px)`;\n    const leftLabelElement = labels.left && html`\n    <label class=\"${GTR_COMPONENT_LABEL_CLASS}\"\n           style=\"\n                left: -${labels.left.size}px;\n                width:  ${leftLabelWidth};\n                justify-content: flex-end;\n                padding-right: 8px;\n           \"\n    >\n        ${TextTrendLabel({\n        trend: labels.left.trend,\n        text: labels.left.text,\n        trendLabelSide: 'left',\n    })}\n    </label>`;\n\n    const rightLabelWidth = `calc(${position === 'left' ? startPercentage : 100 - contentWidth }% + ${labels.right?.size}px)`;\n\n    const rightLabelStyle = hasDynamicLabelPosition\n        ? 'justify-content: flex-end;'\n        : `\n            width: ${rightLabelWidth};\n            justify-content: flex-start;\n        `;\n\n    const rightLabelElement = labels.right && html`\n    <label class=\"${GTR_COMPONENT_LABEL_CLASS}\"\n        style=\"\n            left: ${position === 'left' ? startPercentage : contentWidth}%;\n            ${rightLabelStyle}\n        \"\n    >\n    ${TextTrendLabel({\n        trend: labels.right.trend,\n        text: labels.right.text,\n        trendLabelSide: 'right',\n    })}\n    </label>`;\n\n    const componentClass = clsx(\n        GTR_COMPONENT_WITH_LABEL_CLASS,\n        hasDynamicLabelPosition && GTR_COMPONENT_DYNAMIC_LABEL_CLASS,\n    );\n\n    return html`\n        <div class=\"${componentClass}\"\n            style=\"\n                margin: ${centerComponent ? '0 auto' : 'initial'}\n            \"\n        >\n            ${component}\n            ${leftLabelElement}\n            ${rightLabelElement}\n        </div>\n    ` as HTMLDivElement;\n};\n","import './ZeroLine.scss';\n\nimport html from 'nanohtml';\n\ntype ZeroLineProps = {\n    left: string;\n    display: boolean;\n};\n\nexport const ZeroLine = ({\n    display,\n    left,\n}: ZeroLineProps) => html`\n    <div class=\"gtr-zero-line\"\n            style=\"\n            left: ${left};\n            display: ${display ? 'block' : 'none'};\n        \">\n    </div>\n`;\n","import './TextCell.scss';\n\ninterface CustomCellProps {\n    rowIndex: number;\n    columnIndex: number;\n}\n\nexport const getCustomCellId = (rowIndex: number, columnIndex: number) => `custom-cell-${rowIndex.toString()}-${columnIndex.toString()}`;\nexport const CustomCell = ({\n    rowIndex,\n    columnIndex,\n}: CustomCellProps) => {\n    const cell = document.createElement('div');\n    cell.setAttribute('id', getCustomCellId(rowIndex, columnIndex));\n\n    return cell;\n};\n","import './GanttBar.scss';\n\nimport html from 'nanohtml';\n\nimport {\n    GTR_GANTT_BAR_CLASS,\n    GTR_GANTT_EMPTY_BAR_CLASS,\n} from '../../../common/constants';\n\nexport type GanttBarProperties = {\n    start: number;\n    width: number;\n    height: number;\n    borderStyle?: string;\n    color: string;\n    isEmpty?: boolean;\n};\n\nexport function GanttBar({\n    start,\n    width,\n    height,\n    borderStyle,\n    color,\n    isEmpty = false,\n}: GanttBarProperties) {\n    return isEmpty\n        ? html`\n        <div\n            class=\"${GTR_GANTT_BAR_CLASS} ${GTR_GANTT_EMPTY_BAR_CLASS}\"\n            style=\"margin-left: ${start}%\"\n        ></div>\n    `\n        : html`\n        <div\n            class=\"${GTR_GANTT_BAR_CLASS}\"\n            style=\"\n                width: ${width}%;\n                margin-left: ${start}%;\n                height: ${height}px;\n                background-color: ${color};\n                ${borderStyle ?? ''}\n            \"\n        ></div>\n    `;\n}\n","import './GanttChartBarCell.scss';\n\nimport html from 'nanohtml';\n\nimport {\n    GTR_GANTT_BAR_CELL_CLASS,\n    GTR_GANTT_BARS_CLASS,\n    GTR_GANTT_CLASS,\n    GTR_GANTT_LINE_CLASS,\n    GTR_GANTT_LINES_CLASS,\n} from '../../../common/constants';\nimport type { GanttBarProperties } from '../components/GanttBar';\nimport { GanttBar } from '../components/GanttBar';\nimport type { GanttLabelProperties } from '../components/GanttLabel';\nimport { GanttLabel } from '../components/GanttLabel';\nimport { getGanttLines } from '../util';\n\ntype GanttChartBarCellProps = {\n    mainEvent: GanttBarProperties;\n    finalCheck?: GanttBarProperties;\n    label: GanttLabelProperties;\n    minDate: Date;\n    maxDate: Date;\n    labelOffset: number;\n};\n\nfunction GanttLines(\n    minDate: Date,\n    maxDate: Date,\n) {\n    const lines = getGanttLines(minDate, maxDate)\n        .map(({ marginLeft }) => html`\n            <div\n                class=\"${GTR_GANTT_LINE_CLASS}\"\n                style=\"margin-left: ${marginLeft}%\"\n            ></div>\n        `);\n\n    return html`\n        <div class=\"${GTR_GANTT_LINES_CLASS}\">\n            ${lines}\n        </div>\n    `;\n}\n\nfunction GanttBars(\n    mainEvent: GanttBarProperties,\n    finalCheck?: GanttBarProperties,\n) {\n    const mainEventBar = GanttBar(mainEvent);\n    const finalCheckBar = finalCheck\n        ? GanttBar(finalCheck)\n        : undefined;\n\n    return html`\n        <div class=\"${GTR_GANTT_BARS_CLASS}\">\n            ${finalCheckBar}\n            ${mainEventBar}\n    `;\n}\n\nexport function GanttChartBarCell({\n    mainEvent,\n    finalCheck,\n    label,\n    minDate,\n    maxDate,\n    labelOffset,\n}: GanttChartBarCellProps) {\n    const ganttChartLines = GanttLines(minDate, maxDate);\n    const ganttChartBars = GanttBars(mainEvent, finalCheck);\n    const ganttChartLabel = GanttLabel(label);\n\n    return html`\n        <div class=\"${GTR_GANTT_BAR_CELL_CLASS}\">\n            <div\n                class=\"${GTR_GANTT_CLASS}\"\n                style=\"width: calc(100% - ${labelOffset}px)\"\n            >\n                ${ganttChartLines}\n                ${ganttChartBars}\n                ${ganttChartLabel}\n            </div>\n        </div>\n    `;\n}\n","import { scaleTime } from 'd3';\n\nimport { mapDatesToPercentage } from './mapDatesToPercentage';\n\nexport function getGanttLines(min: Date, max: Date) {\n    const lines = scaleTime()\n        .domain([ min, max ])\n        .ticks(8)\n        .map(tickDate => ({\n            lineValue: scaleTime().tickFormat()(tickDate),\n            lineDate: tickDate,\n        }));\n\n    return lines.map(({\n        lineValue,\n        lineDate,\n    }) => ({\n        value: lineValue,\n        marginLeft: mapDatesToPercentage(min, max, min, lineDate),\n    }));\n}\n","import './GanttLabel.scss';\n\nimport html from 'nanohtml';\n\nimport { GTR_GANTT_LABEL_CLASS } from '../../../common/constants';\n\nexport type GanttLabelProperties = {\n    start: number;\n    label: string;\n};\n\nexport function GanttLabel({\n    start,\n    label,\n}: GanttLabelProperties) {\n    return html`\n        <label\n            class=\"${GTR_GANTT_LABEL_CLASS}\"\n            style=\"margin-left: ${start}%\"\n        >\n            ${label}\n        </label>\n    `;\n}\n","import './ReferenceLine.scss';\n\nimport html from 'nanohtml';\n\ninterface ReferenceLineProps {\n    value?: number;\n    widthDenominator: number;\n}\n\nexport const ReferenceLine = ({\n    value,\n    widthDenominator,\n}: ReferenceLineProps) => {\n    if (value === undefined) {\n        return;\n    }\n\n    const referenceLinePercentage = value / widthDenominator * 100;\n\n    return html`\n        <div class=\"gtr-reference-line\"\n            style=\"left: ${referenceLinePercentage}%;\"\n        >\n        </div>\n    `;\n};\n\n","import './SimpleBar.scss';\n\nimport html from 'nanohtml';\n\nimport {\n    GTR_BAR_CLASS,\n    GTR_SIMPLE_BAR_CELL_CLASS,\n    GTR_SIMPLE_BAR_CLASS,\n} from '../../../common/constants';\nimport { computeLeftZeroLine } from '../renderers/common';\nimport { ReferenceLine } from '../renderers/ReferenceLine';\nimport { ZeroLine } from '../renderers/ZeroLine';\nimport { Bar } from './Bar';\n\ntype SimpleBarProps = {\n    value: number;\n    color: string;\n    min: number;\n    max: number;\n    widthDenominator: number;\n    widthPositiveNumbers: number;\n    referenceLineValue?: number;\n};\n\nexport const SimpleBar = ({\n    value,\n    min,\n    max,\n    color,\n    widthDenominator,\n    widthPositiveNumbers,\n    referenceLineValue,\n}: SimpleBarProps) => {\n    const referenceLine = ReferenceLine({\n        value: referenceLineValue,\n        widthDenominator,\n    });\n\n    const leftZeroLine = computeLeftZeroLine({\n        min,\n        max,\n        widthPositiveNumbers,\n    });\n\n    const isNegative = min < 0;\n    const zeroLine = ZeroLine({\n        left: `${leftZeroLine}`,\n        display: isNegative || referenceLine !== undefined,\n    });\n\n    return html`\n    <div class=\"${GTR_SIMPLE_BAR_CLASS} ${GTR_SIMPLE_BAR_CELL_CLASS}\">\n    ${ zeroLine }\n    ${ referenceLine }\n    ${ Bar({\n        value,\n        min,\n        max,\n        color,\n        widthDenominator,\n        widthPositiveNumbers,\n        className: GTR_BAR_CLASS,\n    })}\n    </div> ` as HTMLDivElement;\n};\n","import './StackedBar.scss';\n\nimport clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport {\n    BLUE,\n    GTR_BAR_CLASS,\n    GTR_STACKED_BAR_CLASS,\n} from '../../../common/constants';\nimport {\n    computeLeftZeroLine,\n    computeWidthDenominator,\n    computeWidthPositiveNumbers,\n} from '../renderers/common';\nimport { ZeroLine } from '../renderers/ZeroLine';\nimport { clampedSum } from '../util/clampedSum';\nimport { Bar } from './Bar';\n\ntype StackedBarProps = {\n    bars: number[];\n    max: number;\n    color: (index: number) => string;\n    min: number;\n    className?: string;\n};\n\nexport const StackedBar = ({\n    bars,\n    max,\n    min,\n    color = () => BLUE,\n    className = '',\n}: StackedBarProps) => {\n\n    const totalWidth = clampedSum(bars, max);\n    if (totalWidth > max) {\n        throw Error(`A stacked bar should sum up to at most ${ max }, but a total of ${totalWidth} was found.`);\n    }\n\n    const widthDenominator = computeWidthDenominator({\n        min,\n        max,\n    });\n\n    const widthPositiveNumbers = computeWidthPositiveNumbers({\n        min,\n        widthDenominator,\n    });\n\n    const leftZeroLine = computeLeftZeroLine({\n        min,\n        max,\n        widthPositiveNumbers,\n    });\n\n    const isNegative = min < 0;\n    const zeroLine = ZeroLine({\n        left: `${leftZeroLine}%`,\n        display: isNegative,\n    });\n\n    return html`<div class=\"${clsx(GTR_STACKED_BAR_CLASS, className)}\">\n    ${\n    zeroLine\n}\n    ${\n    bars.map((value, index) => Bar({\n        value,\n        min,\n        max,\n        color: color(index),\n        widthDenominator,\n        widthPositiveNumbers,\n        className: GTR_BAR_CLASS,\n    }))\n}\n    </div>` as HTMLDivElement;\n};\n","import './CompareBarCell.scss';\n\nimport tinycolor from '@ctrl/tinycolor';\nimport html from 'nanohtml';\n\nimport {\n    BLUE,\n    CONTRAST_ALPHA,\n    GTR_BAR_CLASS,\n    GTR_COMPARE_BAR_CELL_CLASS,\n    GTR_COMPARE_BAR_CLASS,\n    GTR_COMPARE_BAR_CONTAINER_CLASS,\n} from '../../../common/constants';\nimport { assert } from '../../../common/util/assert';\nimport { Bar } from '../components/Bar';\nimport { ComponentWithLabel } from '../components/ComponentWithLabel';\nimport type { TrendBounds } from '../models/ColumnWithTrend';\nimport { getMaxLabelSize } from '../util';\nimport { getLabels } from '../util/getLabels';\nimport {\n    computeLabelCount,\n    computeLeftMargin,\n    computeLeftZeroLine,\n    computePercentageTotal,\n    computeWidthDenominator,\n    computeWidthPositiveNumbers,\n} from './common';\nimport type { CompareBarCellData } from './models';\nimport { ZeroLine } from './ZeroLine';\n\ntype CompareBarCellProps = {\n    data: CompareBarCellData;\n    backgroundColor?: string;\n    compareBackgroundColor?: string;\n    max: number;\n    min: number;\n    trendBounds?: TrendBounds;\n};\n\nexport const CompareBarCell = ({\n    data,\n    max,\n    min,\n    trendBounds,\n    backgroundColor = BLUE,\n    compareBackgroundColor,\n}: CompareBarCellProps) => {\n    const {\n        current,\n        previous,\n        trend: trendData,\n    } = data;\n\n    const isNegativeMin = min < 0;\n    const isNegativeMax = max < 0;\n\n    const widthDenominator = computeWidthDenominator({\n        min,\n        max,\n    });\n\n    const widthPositiveNumbers = computeWidthPositiveNumbers({\n        min,\n        widthDenominator,\n    });\n\n    const maxAbsolute = Math.max(Math.abs(min), max);\n\n    assert(\n        maxAbsolute >= current && maxAbsolute >= previous,\n        `Maximum (${maxAbsolute}) cannot be lower than bar current (${current}) or previous (${previous}).`,\n    );\n\n    const compare = {\n        backgroundColor: compareBackgroundColor ?? tinycolor(backgroundColor)\n            .setAlpha(CONTRAST_ALPHA)\n            .toRgbString(),\n        width: Math.abs(previous) / widthDenominator * 100,\n    };\n\n    const bar = {\n        width: Math.abs(current) / widthDenominator * 100,\n        backgroundColor,\n    };\n\n    const currentBar = Bar({\n        value: current,\n        min,\n        max,\n        color: bar.backgroundColor,\n        widthDenominator,\n        widthPositiveNumbers,\n        className: GTR_BAR_CLASS,\n    });\n\n    const compareBar = Bar({\n        value: previous,\n        min,\n        max,\n        color: compare.backgroundColor,\n        widthDenominator,\n        widthPositiveNumbers,\n        className: GTR_COMPARE_BAR_CLASS,\n    });\n\n    const leftZeroLine = computeLeftZeroLine({\n        min,\n        max,\n        widthPositiveNumbers,\n    });\n\n    const zeroLine = ZeroLine({\n        left: `${leftZeroLine}`,\n        display: true,\n    });\n\n    const biggestPositive = current < 0 && previous < 0 ? Math.min(current, previous) : Math.max(current, previous);\n    const percentageTotal = computePercentageTotal({\n        min,\n        values: [ biggestPositive ],\n        widthDenominator,\n    });\n\n    const compareAndCurrentBar = html`\n    <div class=\"${GTR_COMPARE_BAR_CELL_CLASS}\">\n        ${zeroLine}\n        <div class=\"${GTR_COMPARE_BAR_CONTAINER_CLASS}\">\n            ${currentBar}\n            ${compareBar}\n        </div>\n    </div>\n    ` as HTMLDivElement;\n\n    const trendLabelSize = trendBounds != null\n        ? getMaxLabelSize(trendBounds.min, trendBounds.max) + 14\n        : 0;\n\n    const label = trendData != null\n        ? {\n            text: '',\n            size: trendLabelSize,\n            trend: trendData,\n        }\n        : undefined;\n\n    const result = ComponentWithLabel({\n        component: compareAndCurrentBar,\n        contentWidth: percentageTotal,\n        labels: getLabels({\n            headLabel: label,\n            isNegativeBar: biggestPositive < 0,\n        }),\n        position: biggestPositive < 0 ? 'left' : 'right',\n        isAllPositive: !isNegativeMax && !isNegativeMin,\n    });\n\n    const labelCount = computeLabelCount({\n        min,\n        max,\n    });\n\n    const width = `calc(100% - ${ trendLabelSize * labelCount}px)`;\n    const margin = `${isNegativeMin && !isNegativeMax ? '0 auto' : 'initial'}`;\n\n    result.style.setProperty('width', width);\n    result.style.setProperty('margin', margin);\n    result.style.setProperty('margin-left', `${\n        computeLeftMargin({\n            min,\n            max,\n            headLabelSize: trendLabelSize,\n        })\n    }`);\n\n    return result;\n};\n","import './HeaderCell.scss';\n\nimport clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport type { TextAlignment } from '../../../common/constants';\nimport {\n    GTR_HEADER_CELL_CLASS,\n    GTR_HEADER_CELL_MANDATORY_CLASS,\n    GTR_SORT_NONE,\n    GTR_SORTABLE,\n} from '../../../common/constants';\nimport { AlignedLabel } from '../components/AlignedLabel';\nimport { SortIcon } from '../components/sorting/SortIcon';\n\nconst SORT_CLASS = `${ GTR_SORTABLE } ${ GTR_SORT_NONE }`;\n\ntype HeaderCellProps = {\n    label: string;\n    subtitle?: string;\n    style?: string;\n    align?: TextAlignment;\n    isSortable?: boolean;\n    isMandatory?: boolean;\n};\n\nconst headerWithSubtitle = (element: HTMLElement, subtitle: string) => html`\n    <div style=\"display: flex; flex-direction: column\">\n            ${basicHeader(element)}\n            <div class=\"gtr-header-subtitle\">\n                ${subtitle}\n            </div>\n    </div>\n`;\n\nconst basicHeader = (element: HTMLElement) => html`\n            <div style=\"min-width: 0;\">\n                ${element}\n            </div>\n`;\n\nconst wrapSortableHeaderElement = (element: HTMLElement, align: TextAlignment, subtitle?: string) => html`\n        <div role=\"button\"\n            style=\"width:100%; display: flex; gap: 8px; align-items: center; justify-content: ${align === 'right' ? 'flex-end' : 'flex-start'}\"\n        >\n            ${subtitle ? headerWithSubtitle(element, subtitle) : basicHeader(element)}\n            ${SortIcon()}\n        </div>\n    `;\n\nexport const HeaderCell = ({\n    label,\n    subtitle,\n    align = 'left',\n    style = '',\n    isSortable = false,\n    isMandatory = false,\n}: HeaderCellProps) => {\n    const headerCellClass = clsx(\n        GTR_HEADER_CELL_CLASS,\n        isSortable && SORT_CLASS,\n        isMandatory && GTR_HEADER_CELL_MANDATORY_CLASS\n    );\n\n    const headerLabel = AlignedLabel({\n        label,\n        align,\n    });\n\n    // TODO DNA-923: add translations to DUF\n    const sortLabel = `Sort column ${label}`;\n\n    const headerContent = isSortable\n        ? wrapSortableHeaderElement(headerLabel, align, subtitle)\n        : subtitle\n            ? headerWithSubtitle(headerLabel, subtitle)\n            : headerLabel;\n\n    const headerCell = html`\n        <div class=\"${headerCellClass}\"\n             role=\"columnheader\"\n             style=\"${style}\"\n             tabindex=\"0\"\n        >\n            ${headerContent}\n        </div>\n    ` as HTMLDivElement;\n\n    if (isSortable) {\n        headerCell.setAttribute('aria-label', sortLabel);\n    }\n\n    return headerCell;\n};\n","import html from 'nanohtml';\n\nexport const SortIcon = () => html`\n    <svg\n        class=\"sort-icon\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        viewBox=\"0 0 24 24\"\n    >\n        <path\n            d=\"M12 11.8l2.5 2.5 1.1-1.1L12 9.7l-3.6 3.5 1.1 1.1z\"\n            class=\"path-asc\"\n            transform=\"translate(0 -3)\"\n        />\n        <path\n            d=\"M12 12.2L9.5 9.7l-1.1 1.1 3.6 3.5 3.6-3.5-1.1-1.1z\"\n            class=\"path-desc\"\n            transform=\"translate(0 3)\"\n        />\n    </svg>\n`;\n","import './TableHeader.scss';\n\nimport html from 'nanohtml';\n\nimport {\n    GTR_HEADER_CELL_ACTION_CLASS,\n    GTR_HEADER_CELL_ACTION_LEFT_CLASS,\n    GTR_HEADER_CELL_ACTION_RIGHT_CLASS,\n    GTR_HEADER_CELL_STATUS_CLASS,\n    GTR_HEADER_CELL_WRAPPER_CLASS,\n    GTR_HEADER_CLASS,\n    GTR_ROW_CLASS,\n} from '../../../common/constants';\nimport { GUTTER_SIZE } from '../constants';\nimport type { ExtendedColumn } from '../models';\nimport { HeaderCell } from '../renderers/HeaderCell';\nimport { rowMinWidth } from '../util';\nimport { getColumnAlignment } from '../util/getColumnAlignment';\nimport { mapColumnToMinSize } from '../util/mapColumnToMinSize';\n\nconst createHeaderCells = <TRowData, TChartMeta>(\n    columns: Array<ExtendedColumn<TRowData, TChartMeta>>\n) => columns.map(\n    (column, columnIndex) => {\n        const isColumnSortable = column.sortable ?? false;\n        const isColumnMandatory = column.status?.isMandatory ?? false;\n        const align = getColumnAlignment(column);\n\n        const headerCellWidth = align === 'right'\n            ? 'fit-content'\n            : 'calc(100% - 24px)';\n\n        const headerCell = HeaderCell({\n            label: column.name,\n            subtitle: column.subtitle,\n            align,\n            style: `width: ${column.action ? headerCellWidth : '100%'};`,\n            isSortable: isColumnSortable,\n            isMandatory: isColumnMandatory,\n        });\n\n        headerCell.setAttribute('aria-sort', 'none');\n        headerCell.dataset.columnIndex = columnIndex.toString();\n\n        const actionPositionClass = column.action?.position === 'right'\n            ? GTR_HEADER_CELL_ACTION_RIGHT_CLASS\n            : GTR_HEADER_CELL_ACTION_LEFT_CLASS;\n        const actionElement = column.action\n            ? html`<div\n                role=\"button\"\n                tabindex=\"0\"\n                class=\"${GTR_HEADER_CELL_ACTION_CLASS} ${actionPositionClass}\"\n                data-tooltip-content=\"${column.action.tooltip}\"\n                data-columnindex=\"${columnIndex}\"\n            >\n                ${column.action.icon}\n            </div>`\n            : undefined;\n\n        const isFirstOrLast = columnIndex === 0 || columnIndex === columns.length - 1;\n        const minWidth = mapColumnToMinSize(column) - (isFirstOrLast ? GUTTER_SIZE / 2 : GUTTER_SIZE);\n\n        const wrapperStyle = `\n            justify-content: ${align === 'right' ? 'flex-end' : 'flex-start'};\n            width: ${column.size}%;\n            min-width: ${minWidth}px;\n        `;\n\n        const statusElement = column.status?.icon\n            ? html`<div\n                tabindex=\"0\"\n                class=\"${GTR_HEADER_CELL_STATUS_CLASS}\"\n                data-tooltip-content=\"${column.status.tooltip}\"\n                data-columnindex=\"${columnIndex}\"\n                role=\"img\"\n                alt=\"${column.status.tooltip}\"\n            >\n                ${column.status.icon}\n            </div>`\n            : undefined;\n\n        const headerContent = column.action?.position === 'right'\n            ? html`\n            ${headerCell}\n            ${actionElement}\n            `\n            : html`\n            ${actionElement}\n            ${headerCell}\n            `;\n        return html`\n            <div class=\"${GTR_HEADER_CELL_WRAPPER_CLASS}\"\n                style=\"${wrapperStyle}\"\n            >\n                ${statusElement}\n                ${headerContent}\n            </div>\n        `;\n    });\n\nexport const TableHeader = <TRowData, TChartMeta>(\n    columns: Array<ExtendedColumn<TRowData, TChartMeta>>,\n): HTMLDivElement => html`\n        <div class=\"${GTR_ROW_CLASS} ${GTR_HEADER_CLASS}\"\n             style=\"min-width: ${rowMinWidth(columns)}px;\"\n             data-state=\"loaded\"\n             role=\"row\">\n             ${createHeaderCells(columns)}\n        </div>\n    ` as HTMLDivElement;\n","import './ExpandButton.scss';\n\nimport clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport { GTR_EXPAND_BUTTON } from '../../../common/constants';\nimport { ExpandIcon } from './expand/ExpandIcon';\n\nexport enum ExpandButtonState {\n    None = 0,\n    Expanded = 1,\n    Collapsed = 2,\n}\n\ninterface ExpandButtonProperties {\n    state: ExpandButtonState;\n    rowIndex: number;\n    className?: string;\n}\n\nexport const ExpandButton = ({\n    state,\n    rowIndex,\n    className,\n}: ExpandButtonProperties) => {\n    if (state === ExpandButtonState.None) {\n        return null;\n    }\n\n    const buttonClass = clsx(\n        GTR_EXPAND_BUTTON,\n        state === ExpandButtonState.Expanded && 'expanded',\n        className,\n    );\n\n    return html`\n        <button role='button'\n            class='${buttonClass}'\n            data-row-index='${rowIndex}'\n            aria-label='${state === ExpandButtonState.Expanded ? `Collapse row ${rowIndex + 1}` : `Expand row ${rowIndex + 1}` }'>\n           ${ExpandIcon()}\n        </button>\n    `;\n};\n","import html from 'nanohtml';\n\nexport const ExpandIcon = () => html`\n    <svg class=\"expand-icon\" width=\"30\" height=\"30\" viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n        <path d=\"M13.825 6.91248L10 10.7291L6.175 6.91248L5 8.08748L10 13.0875L15 8.08748L13.825 6.91248Z\" fill=\"#a4b1b8\"/>\n    </svg>\n`;\n","import clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport {\n    GTR_EVEN_CLASS,\n    GTR_ODD_CLASS,\n    GTR_ROW_CLASS,\n} from '../../../common/constants';\nimport type { RowState } from '../models';\n\ninterface RowProperties {\n    index: number;\n    state: RowState;\n    minWidth: number;\n    height: number;\n    className?: string;\n}\n\nexport const TableRow = ({\n    index,\n    state,\n    minWidth,\n    height,\n    className,\n}: RowProperties) => {\n    const rowParityClass = index % 2 === 0\n        ? GTR_ODD_CLASS\n        : GTR_EVEN_CLASS;\n\n    const rowClass = clsx(\n        GTR_ROW_CLASS,\n        rowParityClass,\n        className,\n    );\n\n    return html`\n        <div class=\"${rowClass}\"\n                role=\"row\"\n                data-state=${state}\n                aria-rowindex=\"${index}\"\n                style=\"\n                    height: ${height}px;\n                    min-width: ${minWidth}px;\n                \"\n        >\n        </div>\n    ` as HTMLDivElement;\n};\n","import clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport {\n    GTR_EVEN_CLASS,\n    GTR_EXPANDABLE_ROW_CLASS,\n    GTR_EXPANDABLE_ROW_CONTENT_CLASS,\n    GTR_EXPANDABLE_ROW_CONTENT_ID,\n    GTR_ODD_CLASS,\n    GTR_ROW_CELLS_CONTAINER_CLASS,\n    GTR_ROW_CLASS,\n    GTR_ROW_EXPANDED_CLASS,\n} from '../../../common/constants';\nimport type { RowState } from '../models';\n\ninterface RowProperties {\n    index: number;\n    state: RowState;\n    isExpanded: boolean;\n    minWidth: number;\n    height: number;\n    className?: string;\n}\n\nexport const TableExpandableRow = ({\n    index,\n    isExpanded,\n    className,\n    minWidth,\n    height,\n    state,\n}: RowProperties) => {\n    const rowParityClass = index % 2 === 0\n        ? GTR_ODD_CLASS\n        : GTR_EVEN_CLASS;\n\n    const rowClass = clsx(\n        GTR_ROW_CLASS,\n        GTR_EXPANDABLE_ROW_CLASS,\n        rowParityClass,\n        isExpanded && GTR_ROW_EXPANDED_CLASS,\n        className,\n    );\n\n    return html`\n        <div class='${rowClass}'\n            data-row-index=${index}\"\n            role=\"row\"\n            data-state=${state}\n            aria-rowindex=\"${index}\">\n            <div class='${GTR_ROW_CELLS_CONTAINER_CLASS}'\n                style=\"\n                    height: ${height}px;\n                    min-width: ${minWidth}px;\n                \">\n            </div>\n\n            ${isExpanded\n        ? html`<div class='${GTR_EXPANDABLE_ROW_CONTENT_CLASS}'\n            id='${GTR_EXPANDABLE_ROW_CONTENT_ID}-${index}'\n            data-content-populated=''\n            data-parent-row='${index - 1}'\"></div>`\n        : ''}\n        </div>\n    ` as HTMLDivElement;\n};\n","import clsx from 'clsx';\nimport html from 'nanohtml';\n\nimport {\n    GTR_CELL_CLASS,\n    GTR_CELL_RESIZING_CLASS,\n} from '../../../common/constants';\nimport { assert } from '../../../common/util';\nimport type { InteractiveColumn } from '../models';\nimport { mapColumnToMinSize } from '../util/mapColumnToMinSize';\n\ninterface ContentCellProperties<TRowData, TMetaData> {\n    column: InteractiveColumn<TRowData, TMetaData>;\n    className?: string;\n    rowIndex?: number;\n    columnIndex?: number;\n    hasRowHeader?: boolean;\n}\n\nexport const ContentCell = <TRowData, TMetaData>({\n    column,\n    className,\n    rowIndex = -1,\n    columnIndex = -1,\n    hasRowHeader = false,\n}: ContentCellProperties<TRowData, TMetaData>) => {\n    assert(!hasRowHeader || columnIndex >= 0, 'Column index must be larger than -1 when using row headers.');\n\n    return html`\n        <div class=\"${clsx(GTR_CELL_CLASS, column.isResizing ? GTR_CELL_RESIZING_CLASS : undefined, className)}\"\n            role=${hasRowHeader && columnIndex === 0 ? 'rowheader' : 'cell'}\n            style=\"\n                width: ${column.size}%;\n                min-width: ${mapColumnToMinSize(column)}px;\n            \"\n            data-type=\"${column.type}\"\n            data-row-index=\"${rowIndex}\"\n            data-column-index=\"${columnIndex}\"\n        >\n        </div>\n    `;\n};\n","import clsx from 'clsx';\n\nimport {\n    GTR_ROW_CELLS_CONTAINER_CLASS,\n    GTR_SELECTED_COLUMN_CLASS,\n    GTR_SELECTED_ROW_CELL_CLASS,\n    GTR_SELECTED_ROW_CLASS,\n} from '../../../../common/constants';\nimport type {\n    ExtendedColumn,\n    SelectableElement,\n    SelectableElementType,\n} from '../../models';\nimport { RowState } from '../../models';\nimport { CellFactory } from '../../renderers';\nimport { rowMinWidth } from '../../util';\nimport { ContentCell } from '../ContentCell';\nimport {\n    ExpandButton,\n    ExpandButtonState,\n} from '../ExpandButton';\nimport { TableExpandableRow } from '../TableExpandableRow';\nimport { TableRow } from '../TableRow';\n\ninterface GenericRowRendererProps<TRowData, TMetaData> {\n    columns: Array<ExtendedColumn<TRowData, TMetaData>>;\n    isSelected?: (selectableElement: SelectableElement<TRowData>) => boolean;\n    isSelecting?: () => boolean;\n    onRowUpdate?: (index: number, data: TRowData) => void;\n    isExpandable?: (rowData: TRowData) => boolean;\n    isExpanded?: (index: number) => boolean;\n    hasRowHeader?: boolean;\n}\n\nconst ROW_HEIGHT = 42;\nconst EXPANDED_CONTENT_HEIGHT = 400;\nconst EXPANDED_ROW_HEIGHT = ROW_HEIGHT + EXPANDED_CONTENT_HEIGHT;\n\nexport class GenericRowRenderer<TRowData, TMetaData> {\n    private _hasRowHeader: boolean;\n    private _columns: Array<ExtendedColumn<TRowData, TMetaData>>;\n    private _isSelected: (selectableElement: SelectableElement<TRowData>) => boolean;\n    private _isSelecting: () => boolean;\n    private _onRowUpdate?: (index: number, data: TRowData) => void;\n\n    private _isExpandable: (rowData: TRowData) => boolean;\n    private _isExpanded: (index: number) => boolean;\n\n    constructor({\n        columns,\n        isSelected = () => false,\n        isSelecting = () => false,\n        isExpandable = () => false,\n        isExpanded = () => false,\n        onRowUpdate,\n        hasRowHeader = false,\n    }: GenericRowRendererProps<TRowData, TMetaData>) {\n        this._columns = columns;\n        this._isSelected = isSelected;\n        this._isSelecting = isSelecting;\n        this._onRowUpdate = onRowUpdate;\n        this._isExpandable = isExpandable;\n        this._isExpanded = isExpanded;\n        this._hasRowHeader = hasRowHeader;\n    }\n\n    renderRow(\n        virtualEntryIndex: number,\n        entryIndex: number,\n        rowData: TRowData,\n    ): HTMLDivElement {\n        const isExpandable = this._isExpandable(rowData);\n\n        const row = !isExpandable\n            ? this.createRow(virtualEntryIndex, RowState.loaded, rowData)\n            : this.createExpandableRow(virtualEntryIndex, RowState.loaded, rowData);\n\n        let expandButtonState = ExpandButtonState.None;\n\n        if (isExpandable) {\n            expandButtonState = this._isExpanded(virtualEntryIndex)\n                ? ExpandButtonState.Expanded\n                : ExpandButtonState.Collapsed;\n        }\n\n        this._columns\n            .map((column, cIndex) => this._renderCell(\n                rowData,\n                column,\n                cIndex,\n                virtualEntryIndex,\n                entryIndex,\n                cIndex === 0 ? expandButtonState : ExpandButtonState.None,\n            ))\n            .forEach(cell => {\n                if (isExpandable) {\n                    row.querySelector(`.${GTR_ROW_CELLS_CONTAINER_CLASS}`)?.appendChild(cell);\n                    return;\n                }\n                row.appendChild(cell);\n            });\n\n        this._onRowUpdate?.(entryIndex, rowData);\n\n        return row;\n    }\n\n    createRow(virtualEntryIndex: number, rowState: RowState, data: TRowData | undefined) {\n        const className = clsx(\n            this._isSelectedRow(virtualEntryIndex, data) && GTR_SELECTED_ROW_CLASS\n        );\n\n        return TableRow({\n            index: virtualEntryIndex + 1,\n            state: rowState,\n            minWidth: rowMinWidth(this._columns),\n            height: ROW_HEIGHT,\n            className,\n        });\n    }\n\n    createExpandableRow(virtualEntryIndex: number, rowState: RowState, data: TRowData | undefined) {\n        const className = clsx(\n            this._isSelectedRow(virtualEntryIndex, data) && GTR_SELECTED_ROW_CLASS\n        );\n\n        return TableExpandableRow({\n            index: virtualEntryIndex + 1,\n            state: rowState,\n            isExpanded: this._isExpanded(virtualEntryIndex),\n            className,\n            minWidth: rowMinWidth(this._columns),\n            height: ROW_HEIGHT,\n        });\n    }\n\n    getRowHeightByIndex = (index: number) => this._isExpanded(index) ? EXPANDED_ROW_HEIGHT : ROW_HEIGHT;\n\n    private _isSelectedRow(virtualEntryIndex: number, data: TRowData | undefined) {\n        return this._isSelected({\n            type: 'row',\n            index: virtualEntryIndex,\n            data,\n        });\n    }\n\n    private _renderCell(\n        rowData: TRowData,\n        column: ExtendedColumn<TRowData, TMetaData>,\n        columnIndex: number,\n        rowIndex: number,\n        entryIndex: number,\n        expandButtonState = ExpandButtonState.None,\n    ) {\n        const cell = ContentCell({\n            column,\n            columnIndex,\n            rowIndex: entryIndex,\n            className: this._getCellSelectionClass(columnIndex),\n            hasRowHeader: this._hasRowHeader,\n        });\n\n        const expandButton = ExpandButton({\n            state: expandButtonState,\n            rowIndex,\n        });\n\n        if (expandButton) {\n            cell.appendChild(expandButton);\n        }\n\n        const cellContent = CellFactory({\n            rowIndex,\n            columnIndex,\n            column,\n            rowData,\n            isSelecting: this._isSelecting,\n        });\n\n        cell.appendChild(cellContent);\n        return cell;\n    }\n\n    private _getCellSelectionClass(columnIndex: number) {\n        const isInSelection = (type: SelectableElementType) => this._isSelected({\n            type,\n            index: columnIndex,\n        });\n\n        return clsx(\n            isInSelection('column') && GTR_SELECTED_COLUMN_CLASS,\n            isInSelection('rowCell') && GTR_SELECTED_ROW_CELL_CLASS\n        );\n    }\n}\n","import html from 'nanohtml';\n\nimport { DUF_CUSTOM_SCROLLBAR_CLASS } from '../../../common/constants';\n\nexport function scrollbarWidth(isCustomScrollbar: boolean = true) {\n    const wrapperClass = isCustomScrollbar ? DUF_CUSTOM_SCROLLBAR_CLASS : '';\n    const wrapper = html`\n        <div class=${wrapperClass}\n            style=\"\n                position: absolute;\n                top: -99999999px;\n                overflow-y: scroll;\n        \">\n        </div>\n    `;\n\n    document.body.appendChild(wrapper);\n    const scrollbarWidthValue = wrapper.offsetWidth - wrapper.clientWidth;\n    wrapper.remove();\n\n    return scrollbarWidthValue;\n}\n","import './GenericTableRenderer.scss';\n\nimport clsx from 'clsx';\nimport html from 'nanohtml';\nimport {\n    fromEvent,\n    merge,\n    Subject,\n} from 'rxjs';\nimport {\n    debounceTime,\n    distinctUntilChanged,\n    map,\n    share,\n    takeUntil,\n    tap,\n} from 'rxjs/operators';\nimport Split from 'split.js';\nimport type {\n    DelegateInstance,\n    Instance,\n} from 'tippy.js';\nimport {\n    delegate,\n    hideAll,\n} from 'tippy.js';\n\nimport {\n    DUF_CUSTOM_SCROLLBAR_CLASS,\n    GTR_CELL_SELECTOR,\n    GTR_EXPANDABLE_ROW_CONTENT_SELECTOR,\n    GTR_HEADER_CELL_ACTION_CLASS,\n    GTR_HEADER_CELL_ACTION_SELECTOR,\n    GTR_HEADER_CELL_SELECTOR,\n    GTR_HEADER_CELL_STATUS_CLASS,\n    GTR_HEADER_CELL_STATUS_SELECTOR,\n    GTR_HEADER_CELL_WRAPPER_SELECTOR,\n    GTR_LOADING_CLASS,\n    GTR_ROW_SELECTOR,\n    GTR_SELECTED_COLUMN_CLASS,\n    GTR_SELECTED_ROW_CELL_CLASS,\n    GTR_SELECTED_ROW_CLASS,\n    GTR_SPINNER,\n    GTR_TABLE_CLASS,\n    GTR_VIEWPORT_CLASS,\n    GTR_VIEWPORT_SCROLL_VISIBLE,\n    GTR_WITH_FOOTER_CLASS,\n} from '../../common/constants';\nimport { DEFAULT_TIPPY_PROPERTIES } from '../../common/constants/defaultTippyProperties';\nimport { assert } from '../../common/util/assert';\nimport { ElementResizeObserver } from '../../common/util/ElementResizeObserver';\nimport { normalize } from '../../common/util/normalize';\nimport type { RecorderInstance } from '../../components';\nimport {\n    InfinityList,\n    Recorder,\n} from '../../components';\nimport {\n    ComponentType,\n    MessageHandler,\n    MessageStatus,\n} from '../../plugins/message-handler';\nimport { TableFocuser } from '../../plugins/table-focuser';\nimport type { LegendRow } from '../../plugins/tabular-legend';\nimport { TabularLegend } from '../../plugins/tabular-legend';\nimport {\n    Selector,\n    SynchronousRowRenderer,\n    TableFooter,\n    TableHeader,\n} from './components';\nimport { ActionManager } from './components/ActionManager';\nimport { ExpandManager } from './components/expand/ExpandManager';\nimport { clearSelection } from './components/selection/util';\nimport { SortManager } from './components/sorting';\nimport { GUTTER_SIZE } from './constants';\nimport type {\n    ActiveSelection,\n    CustomColumn,\n    ExtendedColumn,\n    GenericTableRendererOptions,\n    GenericTableRendererUpdateProps,\n    InteractiveColumn,\n    SelectionChecker,\n} from './models';\nimport type { ExpandProps } from './models/ExpandProps';\nimport type { IndexedCustomColumn } from './models/IndexedCustomColumn';\nimport type {\n    SelectionEvent,\n    SelectionState,\n    ValueSelection,\n} from './models/SelectionState';\nimport { TooltipFactory } from './tooltips';\nimport type { ScrollInfo } from './util';\nimport {\n    isScrollVisible,\n    onHorizontalScroll,\n    onScroll,\n    scrollbarWidth,\n} from './util';\nimport { adjustBarCellLabels } from './util/adjustBarCellLabels';\nimport { createResizeGutter } from './util/createResizeGutter';\nimport { endColumnResize } from './util/endColumnResize';\nimport { mapColumnToMinSize } from './util/mapColumnToMinSize';\nimport { renderCustomRowCells } from './util/renderCustomRowCells';\nimport { resizeColumns } from './util/resizeColumns';\nimport { setColumnDefaultColorIndex } from './util/setColumnDefaultColorIndex';\nimport { setColumnMinMax } from './util/setColumnMinMax';\n\nexport class GenericTableRenderer<TRowData, TMetaData> {\n    get viewport() {\n        return this._viewport;\n    }\n\n    get localStorageKey() {\n        assert(this._id !== undefined, 'GenericTableRenderer: id is not defined');\n        return `${this._id}-gtr`;\n    }\n\n    get storedColumns(): number[] {\n        return JSON.parse(localStorage.getItem(this.localStorageKey) ?? '[]');\n    }\n\n    private _header: HTMLDivElement;\n    private _footer: HTMLDivElement;\n    private _viewport: HTMLDivElement;\n    private _table: HTMLDivElement;\n    private _infinity: InfinityList;\n    private _renderer: SynchronousRowRenderer<TRowData, TMetaData>;\n\n    private _destroyed$ = new Subject<void>();\n    private _selector: Selector<TRowData, TMetaData>;\n    private _tooltip: DelegateInstance;\n    private _sorting?: SortManager;\n    private _tableFocuser: TableFocuser;\n    private _rows = new Map<number, TRowData>();\n    private _columns: Array<InteractiveColumn<TRowData, TMetaData>>;\n    private _customColumns: Array<IndexedCustomColumn<TRowData>>;\n    private _scrollBarWidth: number;\n    private _actionManager: ActionManager<TRowData, TMetaData>;\n    private _expandManager?: ExpandManager<TRowData>;\n    private _messageHandler: MessageHandler;\n    private _splitInstance?: Split.Instance;\n    private _recorder: RecorderInstance;\n\n    private _onSelectCallback?: (selection: SelectionEvent<TRowData>) => void;\n    private _activeSelection: 'none' | ActiveSelection = 'none';\n    private _hasPreRenderFocus: boolean = false;\n    private _hasFooter: boolean;\n    private _hasPersistentColumns: boolean;\n    private _id?: string;\n\n    constructor(\n        parent: HTMLElement,\n        options: GenericTableRendererOptions<TRowData, TMetaData>,\n    ) {\n        this._scrollBarWidth = scrollbarWidth();\n\n        const {\n            columns,\n            dataset,\n            onSelect,\n            onSort,\n            isSelected = () => false,\n            sort,\n            hasPersistentColumns,\n            id,\n            messageMapper,\n            expandOptions,\n            hasRowHeader = false,\n            isLoading = false,\n        } = options;\n\n        this._id = id;\n        this._hasPersistentColumns = hasPersistentColumns ?? false;\n        const hasMatchingColumnCount = hasPersistentColumns\n            && this.storedColumns.length === columns.length;\n\n        const tableColumns = hasPersistentColumns && hasMatchingColumnCount\n            ? columns.map((col, index) => ({\n                ...col,\n                size: this.storedColumns[index],\n            }))\n            : columns;\n\n        this._columns = tableColumns.map(c => ({\n            ...c,\n            min: 0,\n            max: 0,\n            colorIndex: 0,\n        }));\n\n        this._customColumns = this._columns\n            .map((column, index) => ({\n                column,\n                index,\n            }))\n            .filter(c => c.column.type === 'custom')\n            .map(c => ({\n                column: c.column as CustomColumn<TRowData>,\n                index: c.index,\n            }));\n\n        this._hasFooter = this._columns\n            .some((column) => column.footer != null);\n\n        this._header = TableHeader(this._columns);\n        this._viewport = this._createViewport({\n            ...options,\n            columns: this._columns,\n        });\n        this._footer = TableFooter(this._columns);\n\n        this._table = html`\n            <div class=\"${GTR_TABLE_CLASS}\"\n                 role=\"table\"\n                 aria-rowcount=\"0\"\n            >\n                 ${this._header}\n                 ${this._viewport}\n                 ${this._footer}\n            </div>\n        ` as HTMLDivElement;\n\n        this._recorder = Recorder.Instance.register(this._table);\n        parent.appendChild(this._table);\n\n        this._selector = new Selector({\n            viewport: this._table,\n            columns: this._columns,\n        });\n\n        this._actionManager = new ActionManager({\n            columns: this._columns,\n            target: this._header,\n        });\n\n        if (onSelect != null) {\n            this._onSelectCallback = onSelect;\n            this._selector.select$.subscribe(this._onSelect);\n            this._selector.activate();\n        }\n\n        const isSortable = this._columns.some(column => column.sortable);\n        if (isSortable) {\n            this._sorting = new SortManager({\n                target: this._header,\n                onUpdate: (state) => {\n                    onSort?.(state);\n                },\n                isSelecting: () => this._activeSelection !== 'none' && this._activeSelection.direction === 'column',\n            });\n        }\n\n        this._messageHandler = new MessageHandler(this._viewport, messageMapper);\n        this._renderer = this._createRenderer(this._columns, hasRowHeader, isSelected);\n        this._infinity = this._createInfinity(0);\n        this._expandManager = this._createExpandManager(expandOptions);\n        this._splitInstance = this._createSplitInstance();\n        this._tableFocuser = this._createTableFocuser();\n\n        this._tooltip = delegate(this._table, {\n            ...DEFAULT_TIPPY_PROPERTIES,\n            onShow: this._onTooltipShow,\n            target: `${GTR_HEADER_CELL_SELECTOR}, ${GTR_CELL_SELECTOR}, ${GTR_HEADER_CELL_ACTION_SELECTOR}, ${GTR_HEADER_CELL_STATUS_SELECTOR}`,\n        });\n\n        this.update({\n            dataset,\n            sort,\n            isLoading,\n        });\n\n        this._subscribeViewportResize();\n    }\n\n    destroy() {\n        this._destroyed$.next();\n\n        this._tooltip.destroy();\n        this._selector.destroy();\n        this._infinity.destroy();\n        this._sorting?.destroy();\n        this._messageHandler.destroy();\n        this._actionManager.destroy();\n        this._tableFocuser.destroy();\n\n        this._expandManager?.destroy();\n\n        this._table.remove();\n        this._rows.clear();\n        this._splitInstance?.destroy(true, true);\n\n        Recorder.Instance.unregister(this._recorder);\n        ElementResizeObserver.Instance.unobserve(this._viewport);\n    }\n\n    setHorizontalScroll(left: number) {\n        this._viewport.scrollLeft = left;\n        this._setHorizontalMargins({ left });\n    }\n\n    setVerticalScroll(index: number) {\n        this._infinity.scrollToIndex(index);\n    }\n\n    setSelection(selection: SelectionState) {\n        clearSelection(this._table);\n\n        const indices = selection.type === 'index'\n            ? selection.indices\n            : this._getIndicesFromValues(selection);\n\n        const isRowSelection = selection.type === 'index'\n            ? selection.isRowSelection\n            : true;\n\n        const selectionType = isRowSelection ? 'row' : 'column';\n\n        this._activeSelection = indices.length === 0\n            ? 'none'\n            : {\n                direction: selectionType,\n                type: selection.type,\n            };\n\n        isRowSelection\n            ? this._setRowSelection(indices, selection.rowCell)\n            : this._setColumnSelection(indices);\n    }\n\n    update({\n        dataset,\n        sort,\n        isLoading = false,\n    }: GenericTableRendererUpdateProps<TRowData>) {\n        const data = dataset ?? [];\n        const dataSize = data.length;\n        const hasData = dataSize > 0;\n\n        setColumnDefaultColorIndex(this._columns);\n        this._columns.forEach(column => setColumnMinMax(column, data));\n        this._table.setAttribute('aria-rowcount', `${dataSize}`);\n        this._footer.style.display = hasData && this._hasFooter ? '' : 'none';\n\n        const hasBarColumn = this._columns.some(c => c.type === 'bar');\n        const componentType = hasBarColumn\n            ? ComponentType.HorizontalBarChart\n            : ComponentType.Table;\n        this._messageHandler.update(!hasData ? MessageStatus.NoData : undefined, componentType);\n\n        this._renderSpinnerOverlay(isLoading);\n\n        if (this._expandManager) {\n            this._expandManager.data = data;\n        }\n\n        this._renderer.data = data;\n        this._infinity.updateRowCount(dataSize);\n        this._tableFocuser.updateRowCount(dataSize);\n\n        const hasScrollbar = isScrollVisible(this._viewport);\n        this._onScrollVisibilityChange(hasScrollbar);\n\n        if (this._activeSelection !== 'none' && this._activeSelection.type === 'index') {\n            clearSelection(this._table);\n            this._selector.clear();\n            this._activeSelection = 'none';\n        }\n\n        if (sort && this._sorting) {\n            this._sorting.state = sort;\n        }\n    }\n\n    private _headerFocusIn = (event: FocusEvent) => {\n        const isHtmlElement = event.target instanceof HTMLElement;\n        if (!isHtmlElement) {\n            return;\n        }\n\n        this._viewport.scrollLeft = event.target.offsetLeft;\n    };\n\n    private _setColumnSelection = (indices: number[]) => {\n        indices.forEach((columnIndex) => {\n            const columnHeader = this._table.querySelector(`.gtr-header-cell[data-column-index='${columnIndex}']`);\n            const columnCell = this._table.querySelectorAll(`.gtr-cell[data-column-index='${columnIndex}']`);\n\n            if (columnHeader == null || columnCell == null) {\n                return;\n            }\n\n            columnHeader.classList.add(GTR_SELECTED_COLUMN_CLASS);\n            columnCell.forEach(node => node.classList.add(GTR_SELECTED_COLUMN_CLASS));\n        });\n    };\n\n    private _setRowSelection = (indices: number[], rowCell: number | null) => {\n        indices.forEach((rowIndex) => {\n            const row = this._table.querySelector(`.gtr-row[data-infinity-id='${rowIndex}']`);\n\n            if (row == null) {\n                return;\n            }\n\n            row.classList.add(GTR_SELECTED_ROW_CLASS);\n        });\n\n        if (rowCell == null) {\n            return;\n        }\n\n        const rowCells = this._table.querySelectorAll(`.gtr-cell[data-column-index='${rowCell}']`);\n\n        rowCells.forEach(node => node.classList.add(GTR_SELECTED_ROW_CELL_CLASS));\n    };\n\n    private _getIndicesFromValues({\n        rowCell,\n        values,\n    }: ValueSelection) {\n        const [ start, end ] = this._infinity.range;\n        const length = end - start; // exclude the table header row\n        const visibleRowsData = this._renderer.cachedData(Array.from({ length }, (_, idx) => start + idx));\n        const column = this._columns[rowCell];\n        const newIndices: number[] = [];\n\n        assert(column.type === 'text', `Cannot map values from column type ${column.type} to indices`);\n        visibleRowsData.forEach((visibleRowData, idx) => {\n            if (visibleRowData == null) {\n                return;\n            }\n\n            const mappedCell = column.mapper(visibleRowData);\n            const isSelected = values\n                .some(rowCellValue => rowCellValue === (typeof mappedCell === 'string'\n                    ? mappedCell\n                    : mappedCell.value\n                ));\n\n            if (isSelected) {\n                newIndices.push(start + idx);\n            }\n        });\n\n        return newIndices;\n    }\n\n    private _onScrollVisibilityChange = (isScrollBarVisible: boolean) => {\n        const padding = isScrollBarVisible ? this._scrollBarWidth : 0;\n        const scrollBarClasses = [ GTR_VIEWPORT_SCROLL_VISIBLE, DUF_CUSTOM_SCROLLBAR_CLASS ];\n\n        if (isScrollBarVisible) {\n            this._viewport.classList.add(...scrollBarClasses);\n        } else {\n            this._viewport.classList.remove(...scrollBarClasses);\n        }\n\n        const setPadding = (element: HTMLDivElement | undefined) => {\n            element?.style?.setProperty?.('padding-right', `${ padding }px`);\n        };\n\n        setPadding(this._footer);\n        setPadding(this._header);\n    };\n\n    private _onSelect = (selection: SelectionEvent<TRowData>) => {\n        const hasSelection = selection.indices.length > 0;\n        if (!selection.isRowSelection || !hasSelection) {\n            this._onSelectCallback?.(selection);\n            return;\n        }\n\n        const data = this._renderer.cachedData(selection.indices);\n        const hasUndefined = data.some((value) => value == null);\n        assert(!hasUndefined, 'Selection contained undefined data');\n\n        this._onSelectCallback?.({\n            ...selection,\n            rowData: data as TRowData[],\n        });\n    };\n\n    private _createViewport({ onScrollHorizontal }: GenericTableRendererOptions<TRowData, TMetaData>) {\n        const viewPortClass = clsx(\n            GTR_VIEWPORT_CLASS,\n            this._hasFooter && GTR_WITH_FOOTER_CLASS,\n        );\n\n        const viewport = html`\n            <div class=\"${viewPortClass}\" tabindex=\"-1\" role=\"rowgroup\">\n            </div>\n        ` as HTMLDivElement;\n\n        const scroll$ = onScroll(viewport)\n            .pipe(share());\n\n        const hideTooltip$ = scroll$\n            .pipe(tap(() => {\n                hideAll({ duration: 0 });\n            }));\n\n        const scrollMargin$ = onHorizontalScroll(scroll$)\n            .pipe(\n                tap(info => onScrollHorizontal?.(info)),\n                tap(this._setHorizontalMargins),\n            );\n\n        const focusHeader$ = fromEvent<FocusEvent>(this._header, 'focusin')\n            .pipe(\n                tap(this._headerFocusIn)\n            );\n\n        merge(\n            hideTooltip$,\n            scrollMargin$,\n            focusHeader$,\n        )\n            .pipe(takeUntil(this._destroyed$))\n            .subscribe();\n\n        return viewport;\n    }\n\n    private _createRenderer(\n        columns: Array<ExtendedColumn<TRowData, TMetaData>>,\n        hasRowHeader: boolean,\n        isSelected?: SelectionChecker<TRowData>,\n    ) {\n        return new SynchronousRowRenderer({\n            data: [],\n            columns,\n            hasRowHeader,\n            isSelected,\n            recorder: this._recorder,\n            isSelecting: () => this._activeSelection !== 'none',\n            isExpandable: this._isRowExpandable,\n            isExpanded: this._isRowExpanded,\n            onRowUpdate: (index: number, data: TRowData) => this._rows.set(index, data),\n            preRender: () => {\n                this._hasPreRenderFocus = this._viewport.contains(document.activeElement);\n            },\n            postRender: () => {\n                this._tableFocuser?.update(this._hasPreRenderFocus);\n                this._hasPreRenderFocus = false;\n\n                const barCells = this._table.querySelectorAll(`${GTR_CELL_SELECTOR}[data-type=\"bar\"]`);\n                adjustBarCellLabels(barCells);\n            },\n            afterRowMount: (rowIndex: number, rowData: TRowData) => {\n                renderCustomRowCells({\n                    rowIndex,\n                    rowData,\n                    container: this._table,\n                    columns: this._customColumns,\n                });\n                if (this._expandManager?.isExpanded(rowIndex)) {\n                    this._expandManager.populateExpandedContent();\n                }\n            },\n        });\n    }\n\n    private _renderSpinnerOverlay(isLoading: boolean) {\n        const hasSpinner = this._table.querySelector(`.${GTR_SPINNER}`);\n        if (isLoading && hasSpinner) {\n            return;\n        }\n\n        if (!isLoading) {\n            this._viewport.classList.remove(GTR_LOADING_CLASS);\n            this._table.querySelector(`.${GTR_SPINNER}`)?.remove();\n            return;\n        }\n\n        const spinnerOverlay = document.createElement('div');\n        spinnerOverlay.classList.add(GTR_SPINNER);\n        this._viewport.classList.add(GTR_LOADING_CLASS);\n\n        const overlay = document.createElement('div');\n        spinnerOverlay.appendChild(overlay);\n        overlay.classList.add('overlay');\n\n        const spinner = html`\n            <svg class=\"spinner\" viewBox=\"0 0 66 66\" xmlns=\"http://www.w3.org/2000/svg\">\n                <circle class=\"path\" fill=\"none\" stroke-width=\"6\" stroke-linecap=\"round\" cx=\"33\" cy=\"33\" r=\"30\"></circle>\n            </svg>\n        `;\n        spinnerOverlay.appendChild(spinner);\n\n        this._table.appendChild(spinnerOverlay);\n    }\n\n    private _createInfinity(dataSize: number) {\n        return new InfinityList(this._viewport, {\n            count: dataSize,\n            overscan: 5,\n            renderer: this._renderer,\n        });\n    }\n\n    private _createSplitInstance() {\n        if (this._columns.length === 0) {\n            return;\n        }\n\n        const headers = this._table.querySelectorAll<HTMLElement>(GTR_HEADER_CELL_WRAPPER_SELECTOR);\n\n        const originalSizes = this._columns.map(column => column.size);\n        const sizes = normalize(originalSizes);\n        const minSizes = this._columns.map(mapColumnToMinSize);\n\n        const splitInstance = Split(Array.from(headers), {\n            snapOffset: 0,\n            sizes,\n            minSize: minSizes,\n            onDrag: (updatedSizes: number[]) => {\n                this._resizeColumns(updatedSizes);\n            },\n            onDragEnd: () => {\n                endColumnResize(this._table, this._columns);\n            },\n            gutterSize: GUTTER_SIZE,\n            gutter: (index) => createResizeGutter(index, this._columns),\n            gutterStyle: (dim, gutSize) => ({\n                [dim]: `${gutSize}px`,\n                [`min-${dim}`]: `${gutSize}px`,\n            }),\n        });\n\n        /*\n            We immediately call resizeColumns after the instance creation\n            because Split.js adjusts the sizes according to the minSizes.\n            This leads to a mismatch between the HeaderCell sizes and the\n            ContentCell sizes.\n        */\n        this._resizeColumns(splitInstance.getSizes(), false);\n\n        return splitInstance;\n    }\n\n    private _resizeSplitInstance() {\n        /*\n            Split.js only removes event listeners when we preserve the\n            gutters. Hence we need to call the destroy twice: first to\n            remove the event listeners, and a second time to remove the\n            element from the DOM.\n        */\n        this._splitInstance?.destroy(true, true);\n        this._splitInstance?.destroy(false, false);\n\n        this._splitInstance = this._createSplitInstance();\n    }\n\n    private _resizeColumns = (\n        updatedSizes: number[],\n        isResizing: boolean = true\n    ) => {\n        resizeColumns({\n            updatedSizes,\n            columns: this._columns,\n            table: this._table,\n            isResizing,\n        });\n\n        if (this._hasPersistentColumns) {\n            localStorage.setItem(\n                this.localStorageKey,\n                JSON.stringify(this._columns.map(c => c.size)),\n            );\n        }\n        /*\n            Whenever columns are resized, infinity needs to be forcibly\n            rerendered to adjust to the new sizes set by Split.js.\n        */\n        this._infinity.render(true);\n    };\n\n    private _createExpandManager = (expandOptions: ExpandProps<TRowData> | undefined) => {\n        if (!expandOptions) {\n            return;\n        }\n\n        return new ExpandManager<TRowData>(\n            this._viewport,\n            this._infinity,\n            (index) => window.requestAnimationFrame(() => this._tableFocuser.force({\n                row: index,\n                column: -1,\n                isExpandedContent: true,\n            })),\n            expandOptions,\n        );\n    };\n\n    private _createTableFocuser = () => {\n        const tableFocuserProps = {\n            rowInfo: {\n                selector: GTR_ROW_SELECTOR,\n                dataSelector: (value: number) => `${GTR_ROW_SELECTOR}[data-infinity-id=\"${value}\"]`,\n                dataAttribute: 'data-infinity-id',\n                count: this._infinity.options.count,\n            },\n            columnInfo: {\n                selector: GTR_CELL_SELECTOR,\n                dataSelector: (value: number) => `${GTR_CELL_SELECTOR}[data-column-index=\"${value}\"]`,\n                dataAttribute: 'data-column-index',\n                count: this._columns.length,\n            },\n            expandedContentInfo: {\n                selector: GTR_EXPANDABLE_ROW_CONTENT_SELECTOR,\n                dataSelector: (value: number) => `${GTR_EXPANDABLE_ROW_CONTENT_SELECTOR}[data-parent-row=\"${value}\"]`,\n                dataAttribute: 'data-parent-row',\n                count: -1,\n            },\n            scrollIntoView: (index: number) => this._infinity.scrollToIndex(index),\n        };\n\n        return new TableFocuser(this._viewport, tableFocuserProps);\n    };\n\n    private _subscribeViewportResize = () => {\n        ElementResizeObserver.Instance\n            .observe(this._viewport)\n            .pipe(\n                tap(() => {\n                    this._infinity.handleResize();\n                    this._resizeSplitInstance();\n                }),\n                debounceTime(100),\n            )\n            .pipe(\n                map(entry => isScrollVisible(entry.target)),\n                distinctUntilChanged()\n            )\n            .subscribe(this._onScrollVisibilityChange);\n    };\n\n    private _isRowExpandable = (rowData: TRowData) => this._expandManager?.isExpandable(rowData) ?? false;\n\n    private _isRowExpanded = (index: number) => this._expandManager?.isExpanded(index) ?? false;\n\n    private _setHorizontalMargins = ({ left }: Pick<ScrollInfo, 'left'>) => {\n        const setMargin = (element: HTMLDivElement | undefined) => {\n            element?.style?.setProperty('margin-left', `-${left}px`);\n        };\n\n        setMargin(this._footer);\n        setMargin(this._header);\n    };\n\n    private _onTooltipShow = (instance: Instance): void | false => {\n        const element = instance.reference;\n        assert(element instanceof HTMLElement, 'Invalid tooltip target');\n\n        const isColumnAction = element.classList.contains(GTR_HEADER_CELL_ACTION_CLASS);\n        const isColumnStatus = element.classList.contains(GTR_HEADER_CELL_STATUS_CLASS);\n        if (isColumnAction || isColumnStatus) {\n            const tooltip = element.attributes.getNamedItem('data-tooltip-content')?.value ?? '';\n            instance.setContent(tooltip);\n            return;\n        }\n\n        const isHeaderCell = element.role === 'columnheader';\n        const result = isHeaderCell\n            ? this._headerTooltip(element)\n            : this._cellTooltip(element);\n\n        if (!result) {\n            return false;\n        }\n\n        instance.setContent(result);\n    };\n\n    private _headerTooltip = (element: HTMLElement) => {\n        assert(element != null, 'Expected the element to exist');\n\n        const { columnIndex } = element.dataset;\n        if (columnIndex == null) {\n            return false;\n        }\n\n        const column = this._columns[Number.parseInt(columnIndex)];\n        const defaultTooltipSchema: LegendRow[] = [ {\n            cells: [ {\n                text: column.name,\n                role: 'secondary',\n            } ],\n        } ];\n        return TabularLegend(column?.headerTooltipSchema ?? defaultTooltipSchema);\n    };\n\n    private _cellTooltip = (element: HTMLElement) => {\n        assert(element != null, 'Expected the element to exist');\n\n        const {\n            columnIndex,\n            rowIndex,\n        } = element.dataset;\n        if (columnIndex == null || rowIndex == null) {\n            return false;\n        }\n\n        const column = this._columns[\n            Number.parseInt(columnIndex, 10)\n        ];\n        const rowData = this._rows.get(\n            Number.parseInt(rowIndex, 10),\n        );\n\n        if (rowData == null) {\n            return false;\n        }\n\n        return TooltipFactory<TRowData, TMetaData>({\n            column,\n            rowData,\n        });\n    };\n}\n","import './TableFooter.scss';\n\nimport html from 'nanohtml';\n\nimport {\n    GTR_CELL_CLASS,\n    GTR_FOOTER_CLASS,\n    GTR_ROW_CLASS,\n} from '../../../common/constants';\nimport type { ExtendedColumn } from '../models';\nimport { TextCell } from '../renderers';\nimport { rowMinWidth } from '../util';\nimport { getColumnAlignment } from '../util/getColumnAlignment';\nimport { mapColumnToMinSize } from '../util/mapColumnToMinSize';\n\nexport const TableFooter = <TRowData, TMetaData>(\n    columns: Array<ExtendedColumn<TRowData, TMetaData>>,\n) => {\n    const footerCells = columns\n        .map(column =>\n            TextCell({\n                data: column.footer ?? '',\n                style: `\n                    width: ${column.size}%;\n                    min-width: ${mapColumnToMinSize(column)}px;\n                `,\n                className: GTR_CELL_CLASS,\n                align: getColumnAlignment(column),\n            }),\n        );\n\n    return html`\n        <div class=\"${GTR_ROW_CLASS} ${GTR_FOOTER_CLASS}\"\n             style=\"min-width: ${rowMinWidth(columns)};\"\n             data-state=\"loaded\">\n                ${\n    footerCells\n}\n        </div>\n    ` as HTMLDivElement;\n};\n","import { faker } from '@faker-js/faker';\nimport cloneDeep from 'lodash-es/cloneDeep';\nimport html from 'nanohtml';\n\nimport type { TreeData } from '../../../../../../lib/core/visualizations/charts/tree/models';\nimport type { ExtraData } from '../renderTree';\n\nconst MAX_DEPTH = 5;\n\nfunction addChildren(tree: TreeData<ExtraData>, depth: number, datasets: Array<TreeData<ExtraData>>, fullTree: TreeData<ExtraData>) {\n    if (depth > MAX_DEPTH) {\n        return;\n    }\n\n    const childrenCount = faker.number.int({\n        min: 1,\n        max: 3,\n    });\n\n    for (let i = 0; i < childrenCount; i++) {\n        const child = {\n            label: faker.word.sample(),\n            display: i % 2 === 0\n                ? i % 3 === 0\n                    ? Math.random() * 100\n                    : 0\n                : undefined,\n            id: faker.string.uuid(),\n            subLabels: [\n                'hottentottententententoonstelling',\n                `Selected rate ${Math.floor(Math.random() * 100)}%`,\n                `Reference case ${Math.floor(Math.random() * 1000)}`,\n            ] as [ string, string, string],\n            extraData: faker.word.sample(),\n            children: [],\n        };\n        tree.children.push(child);\n        datasets.push(cloneDeep(fullTree));\n\n        const percentage = faker.number.int({\n            min: 0,\n            max: 100,\n        });\n\n        if (percentage < 50) {\n            addChildren(child, depth + 1, datasets, fullTree);\n        }\n    }\n\n}\n\nconst renderRCAIcon = html`\n    <svg width=\"48\" height=\"48\" viewBox=\"0 0 48 48\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M40.968 7.032L37.584 10.416C41.04 13.896 43.2 18.696 43.2 24C43.2 34.608 34.608 43.2 24 43.2C13.392 43.2 4.8 34.608 4.8 24C4.8 14.208 12.12 6.144 21.6 4.968V9.816C14.784 10.968 9.6 16.872 9.6 24C9.6 31.944 16.056 38.4 24 38.4C31.944 38.4 38.4 31.944 38.4 24C38.4 20.016 36.792 16.416 34.176 13.824L30.792 17.208C32.52 18.96 33.6 21.36 33.6 24C33.6 29.304 29.304 33.6 24 33.6C18.696 33.6 14.4 29.304 14.4 24C14.4 19.536 17.472 15.816 21.6 14.736V19.872C20.16 20.712 19.2 22.224 19.2 24C19.2 26.64 21.36 28.8 24 28.8C26.64 28.8 28.8 26.64 28.8 24C28.8 22.224 27.84 20.688 26.4 19.872V0H24C10.752 0 0 10.752 0 24C0 37.248 10.752 48 24 48C37.248 48 48 37.248 48 24C48 17.376 45.312 11.376 40.968 7.032Z\" fill=\"#FA4616\"/>\n    </svg>\n`;\n\nconst highlightPath = (tree: TreeData) => {\n    tree.isHighlighted = true;\n\n    if (tree.children.length === 0) {\n        return;\n    }\n\n    const randomChildIndex = Math.ceil(Math.random() * (tree.children.length - 1));\n    highlightPath(tree.children[randomChildIndex]);\n};\n\nexport function generateTreeData(seed: number = 1337) {\n    faker.seed(seed);\n\n    const root = {\n        label: 'Maverick buying',\n        id: faker.string.uuid(),\n        display: renderRCAIcon as unknown as SVGSVGElement,\n        children: [],\n        isHighlighted: true,\n        extraData: '',\n    };\n\n    const rootCopy = cloneDeep(root);\n    const datasets: Array<TreeData<ExtraData>> = [ ];\n    const tree: TreeData<ExtraData> = root;\n\n    addChildren(tree, 0, datasets, tree);\n    highlightPath(tree);\n\n    return {\n        tree,\n        rootCopy,\n        datasets,\n    };\n}\n"],"names":[],"sourceRoot":""}